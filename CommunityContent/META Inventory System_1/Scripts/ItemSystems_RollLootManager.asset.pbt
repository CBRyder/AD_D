Assets {
  Id: 11300334805317861193
  Name: "ItemSystems_RollLootManager"
  PlatformAssetType: 3
  TextAsset {
    CustomParameters {
      Overrides {
        Name: "cs:RollEntryTemplate"
        AssetReference {
          Id: 18417580940993918629
        }
      }
      Overrides {
        Name: "cs:ReliableEvents"
        AssetReference {
          Id: 14475141008376894138
        }
      }
      Overrides {
        Name: "cs:RollerTemplate"
        AssetReference {
          Id: 16947512388630727784
        }
      }
      Overrides {
        Name: "cs:ItemSystems_Database"
        AssetReference {
          Id: 8583392859467906295
        }
      }
      Overrides {
        Name: "cs:RollExpireTime"
        Int: 30
      }
    }
    Assets {
      Id: 8583392859467906295
      Name: "ItemSystems_Database"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Database\r\n    ====================\r\n\r\n    Reads and indexes the raw data scripts. Provides factory methods for creating items.\r\n]]\r\n\r\nlocal Item = require(script:GetCustomProperty(\"Item\"))\r\n\r\nlocal LOOT_TABLE = World.FindObjectByName(\"LootTables\"):GetChildren()\r\nlocal SALVAGE_TABLE = World.FindObjectByName(\"Salvagables\"):GetChildren()\r\nlocal REGISTERED_ITEMS = World.FindObjectByName(\"RegisteredItems\")\r\nlocal ITEM_TYPES_FOLDER = World.FindObjectByName(\"ItemTypes\")\r\n\r\n--local LOOT_TABLE = script:GetCustomProperty(\"LootTable\"):WaitForObject():GetChildren()\r\n--local SALVAGE_TABLE = script:GetCustomProperty(\"SalvageTable\"):WaitForObject():GetChildren()\r\n--local REGISTERED_ITEMS = script:GetCustomProperty(\"RegisteredItems\"):WaitForObject()\r\n\r\n\r\n\r\n-- Load the database over a fixed number of frames.\r\nlocal LOAD_FRAME_LIMIT = 10\r\n\r\n-- If true, when the game loads it will log all the catalogs and their items that are registered to that catalog.\r\nlocal DEBUGLOGLOAD = false \r\n\r\nlocal DATA_ITEMS = {}\r\nlocal DATA_ITEMTYPES_UPGRADES = {}\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- SETUP\r\n---------------------------------------------------------------------------------------------------------\r\n\r\nlocal function HasRequiredProperties(item)\r\n    if item:GetCustomProperty(\"Name\") and\r\n        item:GetCustomProperty(\"Icon\") and\r\n        item:GetCustomProperty(\"ItemType\") and\r\n        item:GetCustomProperty(\"Rarity\") then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\n-- Load the upgrade items for the item types.\r\nlocal function LoadItemTypeUpgrades(folder)\r\n    if not folder then\r\n        warn(\"No item types folder provided. Can not load upgrade items for items.\")\r\n        return\r\n    end\r\n    for _, itemType in pairs(folder:GetChildren()) do\r\n        local enhacementItem = itemType:GetCustomProperty(\"EnhancementItem\") and itemType:GetCustomProperty(\"EnhancementItem\"):WaitForObject() or nil\r\n        local limitBreakItem = itemType:GetCustomProperty(\"LimitBreakingItem\") and itemType:GetCustomProperty(\"LimitBreakingItem\"):WaitForObject() or nil\r\n\r\n        if enhacementItem and limitBreakItem then\r\n            local itemTypeName = itemType.name\r\n            DATA_ITEMTYPES_UPGRADES[itemTypeName] = { \r\n                enhancmentItemName = enhacementItem:GetCustomProperty(\"Name\"),\r\n                limitBreakingItemName = limitBreakItem:GetCustomProperty(\"Name\")\r\n            }\r\n        elseif enhacementItem or limitBreakItem then\r\n            warn(string.format(\"\\nItem type - %s requires both an enhacement item and a limit breaking item custom property that references an existing item. \\n You currently have one out of the two required properties.\",itemType.name))\r\n        end\r\n    end\r\nend\r\n\r\n-- Recursively load the item database.\r\nlocal function LoadItems_R(root)\r\n    if not root then\r\n        warn(\"unable to load items for database as there is no folder provided to recursively load.\")\r\n        return \r\n    end\r\n    for _, item in pairs(root:GetChildren()) do\r\n        if HasRequiredProperties(item) then\r\n            table.insert(DATA_ITEMS,item)\r\n        elseif #item:GetChildren() > 0 then\r\n            LoadItems_R(item)\r\n        end\r\n    end\r\nend\r\nLoadItems_R(REGISTERED_ITEMS)\r\nLoadItemTypeUpgrades(ITEM_TYPES_FOLDER)\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PUBLIC\r\n---------------------------------------------------------------------------------------------------------\r\nlocal Database = {}\r\n\r\nfunction Database:WaitUntilLoaded()\r\n    while not self.isLoaded do\r\n        Task.Wait()\r\n    end\r\nend\r\n\r\n-------------- Item Factory Methods --------------\r\n-- These methods are for creating items without stats.\r\n-- This is useful for adding items to the inventory or checking for items.\r\n\r\nfunction Database:GetItemFromName(itemName)\r\n    local itemData = Database:FindItemDataByName(itemName)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right name?\",itemName))\r\n    end\r\n    return item\r\nend\r\n\r\nfunction Database:GetItemFromMUID(muid)\r\n    local itemData = Database:FindItemDataByFullMUID(muid) or Database:FindItemDataByMUID(muid)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right muid?\",muid))\r\n    end\r\n    local item = Item.New(itemData)\r\n    return item\r\nend\r\n\r\nfunction Database:GetItemFromIndex(index)\r\n    local itemData = Database:FindItemDataByIndex(index)\r\n    local item = Item.new(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right index?\",index))\r\n    end\r\n    return item\r\nend\r\n\r\nfunction Database:CreateItemFromHash(itemHash)\r\n    local item = Item.FromHash(self, itemHash)\r\n    if not item then\r\n        warn(string.format(\"Failed to create item - %s from database. This may not be a valid hash.\",itemHash))\r\n    end\r\n    return item\r\nend\r\n\r\n-------------- Loot Factory Methods ---------------\r\n-- These methods are for creating items that roll for stats\r\n-- This is useful for creating items that need stats.\r\n\r\nfunction Database:CreateLootItemFromName(itemName)\r\n    local itemData, min, max = Database:FindItemDataByName(itemName)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right name?\",itemName))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\nfunction Database:CreateLootItemFromMUID(muid)\r\n    local itemData, min, max = Database:FindItemDataByFullMUID(muid) or Database:FindItemDataByMUID(muid)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right muid?\",muid))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\nfunction Database:CreateLootItemFromIndex(index)\r\n    local itemData, min, max = Database:FindItemDataByIndex(index)\r\n    local item = Item.new(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right index?\",index))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\n-- Create a random item from a loot table when provided a name of an existing loot table.\r\nfunction Database:CreateLootItemFromDropKey(dropKey)\r\n    local itemData, min, max = self:_RollDrop(dropKey)\r\n    if not itemData then\r\n        warn(string.format([[ \r\n        Failed to create item from - %s loot table. Does this loot table exist in item registry?\r\n        ]],dropKey))\r\n        return nil\r\n    end\r\n    if itemData == nil or itemData == \"Empty\" then return end\r\n    --assert(itemData, string.format(\"Could not drop an item from %s loot table as it does not exist.\", dropKey))\r\n    local item = Item.New(itemData)\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item \r\nend\r\n\r\nfunction Database:CreateLootItemFromItemData(itemData)\r\n    itemData._RollStats = self:_GetRollFunction(itemData.statKey)\r\n    local item = Item.New(itemData)\r\n    self:_RollItemStats(item)\r\n    return item \r\nend\r\n-----------------------------------------------\r\n\r\n-- Returns a table containing the data of an item when provided with the name of the item. Example: 1\r\nfunction Database:FindItemDataByIndex(itemIndex)\r\n    return self.itemDatasByIndex[itemIndex]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with the name of the item. Example: Wood\r\nfunction Database:FindItemDataByName(itemName)\r\n    return self.itemDatasByName[itemName]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with a full MUID. Example: F2F89CB6DC0893B7:ITEM_Misc_Wood\r\nfunction Database:FindItemDataByFullMUID(itemMUID)\r\n    return self.itemDatasByMUIDFull[itemMUID]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with a MUID. Example: F2F89CB6DC0893B7\r\nfunction Database:FindItemDataByMUID(itemMUID)\r\n    return self.itemDatasByMUID[itemMUID]\r\nend\r\n\r\nfunction Database:RandomDropKey()\r\n    return self.itemDropKeys[math.random(#self.itemDropKeys)]\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PRIVATE\r\n---------------------------------------------------------------------------------------------------------\r\nfunction Database:_Init()\r\n    self.itemStatRollInfos = {}\r\n    Task.Spawn(function()\r\n        self:_LoadItems()\r\n        self:_LoadDrops()\r\n        self.isLoaded = true\r\n    end)\r\nend\r\n\r\n-- Finds the stats folder of an item and loads it.\r\nfunction Database:_LoadStats(item,itemPropName)\r\n    local stats = item:FindChildByName(\"Stats\")\r\n    if stats == nil then return end\r\n    self.itemStatRollInfos[itemPropName] = self.itemStatRollInfos[itemPropName] or { base = {}, bonus = {} }\r\n    local statRollInfos = self.itemStatRollInfos[itemPropName]\r\n    for _,statFolder in ipairs(stats:GetChildren()) do\r\n        if statFolder.name == \"Base\" then\r\n            for _, stat in ipairs(statFolder:GetChildren()) do\r\n                local min = stat:GetCustomProperty(\"Min\")\r\n                local max = stat:GetCustomProperty(\"Max\")\r\n                local likelihood = stat:GetCustomProperty(\"Likelihood\")\r\n                local rollInfo = { statName = stat.name, rollMin = tonumber(min), rollMax = tonumber(max), likelihood = tonumber(likelihood) }\r\n                table.insert(statRollInfos.base, rollInfo)\r\n            end\r\n        else\r\n            for _, stat in ipairs(statFolder:GetChildren()) do\r\n                local min = stat:GetCustomProperty(\"Min\")\r\n                local max = stat:GetCustomProperty(\"Max\")\r\n                local likelihood = stat:GetCustomProperty(\"Likelihood\")\r\n                statRollInfos.bonus[statFolder.name] = statRollInfos.bonus[statFolder.name] or { cumulativeLikelihood = 0 }\r\n                local bonusGroup = statRollInfos.bonus[statFolder.name]\r\n                bonusGroup.cumulativeLikelihood = bonusGroup.cumulativeLikelihood + likelihood\r\n                local rollInfo = { statName = stat.name, rollMin = tonumber(min), rollMax = tonumber(max), likelihood = tonumber(likelihood) }\r\n                table.insert(bonusGroup, rollInfo)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-- Finds the assiociated salvage components folder for the item and loads the componenents into a table\r\nfunction Database:_LoadSalvageComponents(itemTemplate)\r\n    for _, salvagableItem in pairs(SALVAGE_TABLE) do\r\n        if salvagableItem:GetCustomProperty(\"ItemToSalvage\") == itemTemplate then\r\n            local resources = {}\r\n            for i, component in pairs(salvagableItem:GetChildren()) do\r\n                local componentProperties = component:GetCustomProperties()\r\n                assert(componentProperties[\"ItemProduct\"],string.format(\"%s in salvagables folder contains a component that does not have an assigned item.\",salvagableItem.name))\r\n                local item = componentProperties[\"ItemProduct\"] -- The item asset reference\r\n                local amount = componentProperties[\"Amount\"] or 1 -- The amount of that item\r\n                table.insert(resources,{ item = item, amount = amount })\r\n            end\r\n            return resources ~= {} and resources or nil\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:_LoadItems()\r\n    self.itemDatasByIndex = {}\r\n    self.itemDatasByName = {}\r\n    self.itemDatasByMUIDFull = {}\r\n    self.itemDatasByMUID = {}\r\n    local index = 1\r\n    if DEBUGLOGLOAD then print(\"Loading Items ----------------------------------------------------- \\n\") end -- Debug\r\n    for index, item in ipairs(DATA_ITEMS) do\r\n        if index % LOAD_FRAME_LIMIT == 0 then Task.Wait() end\r\n        local itemMUID = item:GetCustomProperty(\"Item\")\r\n        local propName = item:GetCustomProperty(\"Name\")\r\n        local propIcon = item:GetCustomProperty(\"Icon\")\r\n        local propMaxStackableSize = item:GetCustomProperty(\"MaxStackableSize\")\r\n        local propItemType = item:GetCustomProperty(\"ItemType\")\r\n        local propDescription = item:GetCustomProperty(\"Description\")\r\n        local propRarity = item:GetCustomProperty(\"Rarity\")\r\n        local propLevelRequirement = item:GetCustomProperty(\"LevelRequirement\")\r\n        local propEquipmentStance = item:GetCustomProperty(\"EquipmentStance\")\r\n        local propConsumptionEffect = item:GetCustomProperty(\"ConsumptionEffect\")\r\n        local propBackpackSlotCount = item:GetCustomProperty(\"BackpackSlotCount\")\r\n        local isBackpack = propBackpackSlotCount and true or false\r\n        local salvageComponents = self:_LoadSalvageComponents(itemMUID) -- Load salvage components for the item\r\n        self:_LoadStats(item,propName) -- Load stats from the item\r\n\r\n        if DEBUGLOGLOAD then print(propName) end -- Debug\r\n        if DEBUGLOGLOAD then print(\"|\",itemMUID, \"    =\",propName) end -- Debug\r\n\r\n        if propMaxStackableSize and not Item.ALLOW_LARGE_STACK_SIZES then\r\n            assert(tonumber(propMaxStackableSize) <= 2^12, string.format(\"item stack size is too large - %s \\n if you want larger stack sizes that exceed 2^12 then enable AllowLargeStacksizes custom property on ItemSystems_Item in project content. Enabling this will allow up to 2^24 increasing the maximum amount for stack sizes.\", propName))\r\n        elseif propMaxStackableSize and Item.ALLOW_LARGE_STACK_SIZES then\r\n            assert(tonumber(propMaxStackableSize) <= 2^24, string.format(\"item stack size is too large - %s \\n You can not exceed 2^24. Consider decreasing the max stack size for this item.\", propName))\r\n        end\r\n\r\n        if propConsumptionEffect then\r\n            assert(require(propConsumptionEffect), \"Could not require consumption effect script from item - %s\", propName)\r\n        end\r\n\r\n        assert(not self.itemDatasByName[propName], string.format(\"duplicate item name is not allowed - %s check your registered items for duplicates\", propName))\r\n        assert(not self.itemDatasByMUIDFull[itemMUID], string.format(\"duplicate item MUID is not allowed - %s on item: %s\", itemMUID, propName))\r\n        assert(Item.SLOT_CONSTRAINTS[propItemType], string.format(\"unrecognized item type - %s from %s add your item type to the ItemTypes folder in ItemRegistry\", propItemType, propName))\r\n        assert(Item.RARITIES[propRarity], string.format(\"unrecognized item rarity - %s check ItemSystems_ItemThemes to make sure this rarity exist.\", propRarity))\r\n\r\n        local isEquippable = Item.SLOT_CONSTRAINTS[propItemType] and true or false\r\n        local stance = propEquipmentStance or nil\r\n        local maxStackSize = propMaxStackableSize ~= nil and propMaxStackableSize > 1 and propMaxStackableSize or nil\r\n        local enhancementItemName = DATA_ITEMTYPES_UPGRADES[propItemType] and DATA_ITEMTYPES_UPGRADES[propItemType].enhancmentItemName or nil\r\n        local limitBreakingItemName = DATA_ITEMTYPES_UPGRADES[propItemType] and DATA_ITEMTYPES_UPGRADES[propItemType].limitBreakingItemName or nil\r\n        local itemData = {\r\n            index = index,\r\n            name = propName,\r\n            iconMUID = propIcon,\r\n            type = propItemType,\r\n            rarity = propRarity,\r\n            levelRequirement = propLevelRequirement,\r\n            stance = stance,\r\n            enhancementItemName = enhancementItemName,\r\n            limitBreakingItemName = limitBreakingItemName,\r\n            isEquippable = isEquippable,\r\n            isBackpack = isBackpack,\r\n            backpackSlotCount = propBackpackSlotCount,\r\n            maxStackSize = maxStackSize,\r\n            muid = itemMUID:match(\"^(.+):\"),\r\n            description = propDescription or \"\",\r\n            consumptionEffect = propConsumptionEffect,\r\n            salvageComponents = salvageComponents,\r\n            _RollStats = Database:_GetRollFunction(propName)\r\n        }\r\n\r\n        index = index + 1\r\n        self.itemDatasByIndex[itemData.index] = itemData\r\n        self.itemDatasByName[itemData.name] = itemData\r\n        self.itemDatasByMUIDFull[itemMUID] = itemData\r\n        self.itemDatasByMUID[itemMUID:match(\"^(.+):\")] = itemData\r\n        if DEBUGLOGLOAD then print(\"\\n\") end -- Debug\r\n    end\r\n    if DEBUGLOGLOAD then print(\"Loading Items Ended -----------------------------------------------\\n\") end -- Debug\r\nend\r\n\r\nfunction Database:_RollItemStats(item)\r\n    item:RollStats()\r\nend\r\n\r\nfunction Database:_GetRollFunction(itemName)\r\n    local _RollStats = function()\r\n        local statRollInfos = self.itemStatRollInfos[itemName]\r\n        if statRollInfos == nil then return end -- If the item does not have stats.\r\n        local stats = {}\r\n        for _,rollInfo in ipairs(statRollInfos.base) do\r\n            local statInfo = Item._StatInfo{\r\n                name = rollInfo.statName,\r\n                value = math.random(rollInfo.rollMin, rollInfo.rollMax),\r\n                isBase = true,\r\n            }\r\n            table.insert(stats, statInfo)\r\n        end\r\n        for _,bonusGroup in pairs(statRollInfos.bonus) do\r\n            local roll = math.random() * bonusGroup.cumulativeLikelihood\r\n            for _,rollInfo in ipairs(bonusGroup) do\r\n                if roll <= rollInfo.likelihood then\r\n                    local statInfo = Item._StatInfo{\r\n                        name = rollInfo.statName,\r\n                        value = math.random(rollInfo.rollMin, rollInfo.rollMax),\r\n                        isBonus = true\r\n                    }\r\n                    table.insert(stats, statInfo)\r\n                    break\r\n                end\r\n                roll = roll - rollInfo.likelihood\r\n            end\r\n        end\r\n        return stats\r\n    end\r\n    return _RollStats\r\nend\r\n\r\nfunction Database:_LoadDrops()\r\n    self.itemDropTables = {}\r\n    self.itemDropKeys = {}\r\n    for _, lootTable in pairs(LOOT_TABLE) do\r\n        if not self.itemDropTables[lootTable.name] then\r\n            self.itemDropTables[lootTable.name] = { cumulativeLikelihood = 0 }\r\n            table.insert(self.itemDropKeys, lootTable.name)\r\n        end\r\n        for _, lootDrop in pairs(lootTable:GetChildren()) do\r\n            local propItem = lootDrop:GetCustomProperty(\"Item\")\r\n            local item = propItem and propItem:GetObject() or \"Empty\"\r\n            local likelihood = lootDrop:GetCustomProperty(\"Likelihood\")\r\n            local minQuantity = lootDrop:GetCustomProperty(\"MinimumStackWhenDropped\")\r\n            local maxQuantity = lootDrop:GetCustomProperty(\"MaximumStackWhenDropped\")\r\n            if item == \"Empty\" and likelihood then\r\n                local dropTable = self.itemDropTables[lootTable.name]\r\n                local dropInfo = { itemName = \"Empty\", likelihood = tonumber(likelihood)}\r\n                table.insert(dropTable, dropInfo)\r\n                dropTable.cumulativeLikelihood = dropTable.cumulativeLikelihood + dropInfo.likelihood\r\n            elseif item ~= \"Empty\" then\r\n                local itemName = item:GetCustomProperty(\"Name\")\r\n                if not self:FindItemDataByName(itemName) then\r\n                    warn(string.format(\"%s group inside the loot table - %s. The group\'s item property does not reference a registered item.\",lootDrop.name,lootTable.name))\r\n                end\r\n                if not likelihood then\r\n                    warn(string.format(\"Likelihood property is missing from %s in loot table %s\",lootDrop.name,lootTable.name))\r\n                end\r\n                if itemName and likelihood then\r\n                    local dropTable = self.itemDropTables[lootTable.name]\r\n                    local dropInfo = { itemName = itemName, likelihood = tonumber(likelihood), min = minQuantity, max = maxQuantity }\r\n                    table.insert(dropTable, dropInfo)\r\n                    dropTable.cumulativeLikelihood = dropTable.cumulativeLikelihood + dropInfo.likelihood\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:_RollDrop(dropKey)\r\n    local dropTable = self.itemDropTables[dropKey]\r\n    if dropTable then\r\n        local roll = math.random() * dropTable.cumulativeLikelihood\r\n        for _,dropInfo in ipairs(dropTable) do\r\n            if roll <= dropInfo.likelihood then\r\n                local item, min, max = self:FindItemDataByName(dropInfo.itemName), dropInfo.min, dropInfo.max \r\n                if dropInfo.itemName == \"Empty\" then\r\n                    return \"Empty\", min, max\r\n                end\r\n                return item, min, max\r\n            end\r\n            roll = roll - dropInfo.likelihood\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:__tostring()\r\n    return \"\"\r\nend\r\n\r\nreturn Database"
        CustomParameters {
          Overrides {
            Name: "cs:Item"
            AssetReference {
              Id: 5903881589588767374
            }
          }
        }
      }
    }
    Assets {
      Id: 5903881589588767374
      Name: "ItemSystems_Item"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Item\r\n    ================\r\n\r\n    Logical representation of an item.\r\n]]\r\nlocal Base64 = require(script:GetCustomProperty(\"Base64\"))\r\nlocal ITEM_TYPES_FOLDER = World.FindObjectByName(\"ItemTypes\")\r\n\r\nlocal Item = {}\r\nItem.__index = Item\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- CONSTANTS\r\n---------------------------------------------------------------------------------------------------------\r\nlocal function Enum(values) for i,v in ipairs(values) do values[v] = i end return values end\r\n\r\nItem.STATS = Enum{\r\n    \"Health\",\r\n    \"HealthPercent\",\r\n    \"Attack\",\r\n    \"Defense\",\r\n    \"Magic\",\r\n    \"CritChance\",\r\n    \"CDR\",\r\n    \"Haste\",\r\n    \"Tenacity\",\r\n    \"Value\",\r\n}\r\n\r\nItem.RARITIES = Enum{\r\n    \"Common\",\r\n    \"Uncommon\",\r\n    \"Rare\",\r\n    \"Epic\",\r\n    \"Legendary\",\r\n}\r\n\r\nItem.SLOT_CONSTRAINTS = {}\r\n\r\nfor _, item in pairs(ITEM_TYPES_FOLDER:GetChildren()) do\r\n    local typeName = item.name\r\n    Item.SLOT_CONSTRAINTS[typeName] = { slotType = item:GetCustomProperty(\"EquipSlotType\"),\r\n                                        isOffHandDisabled = item:GetCustomProperty(\"IsOffHandDisabled\"), }\r\nend\r\n\r\n-- Global flag for allowing 2^24 stack sizes instead of 2^12\r\nItem.ALLOW_LARGE_STACK_SIZES = script:GetCustomProperty(\"AllowLargeStacksizes\")\r\n\r\n-- Enhancement cap.\r\nItem.ENHANCEMENT_CAP = 10\r\nItem.ENHANCEMENT_STAT_PERCENT_INCREASE = 10\r\n\r\n-- Limit break caps by rarity.\r\nItem.LIMIT_BREAK_CAPS = {\r\n    Common    = 1,\r\n    Uncommon  = 2,\r\n    Rare      = 3,\r\n    Epic      = 4,\r\n    Legendary = 5,\r\n}\r\n\r\n-- These are close to the geometric series 4^n, but are chosen to be prime numbers so that combinations look more \"random\".\r\nItem.SHARD_RARITY_MULTIPLIERS = {\r\n    Common      = 3,\r\n    Uncommon    = 7,\r\n    Rare        = 23,\r\n    Epic        = 79,\r\n    Legendary   = 248,\r\n}\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PUBLIC\r\n---------------------------------------------------------------------------------------------------------\r\nfunction Item.New(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    local o = {}\r\n    setmetatable(o, Item)\r\n    o:_Init(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    return o\r\nend\r\n\r\nfunction Item.FromHash(database, itemHash)\r\n    return Item._FromHash(database, itemHash)\r\nend\r\n\r\nfunction Item.StatGreaterThan(item1, item2, statName)\r\n    return item1:GetStatTotal(statName) > item2:GetStatTotal(statName) or false\r\nend\r\n\r\nfunction Item:NewBackpackInventory(Inventory, database, owner, inventoryHash)\r\n    if self:IsBackpack() then\r\n        if not owner then return end\r\n        local newInventory = Inventory.New(database,owner,self.data.backpackSlotCount,nil)\r\n        newInventory:LoadHash(inventoryHash)\r\n        self:SetBackpackInventory(newInventory)\r\n    end\r\nend\r\n\r\nfunction Item:GetBackpackInventory()\r\n    if self:IsBackpack() then\r\n        return self.backpackInventory\r\n    end\r\nend\r\n\r\nfunction Item:SetBackpackInventory(inventory)\r\n    if self:IsBackpack() then\r\n        self.backpackInventory = inventory\r\n    end\r\nend\r\n\r\nfunction Item:RuntimeHash()\r\n    return self:_IntoHash(true)\r\nend\r\n\r\nfunction Item:PersistentHash()\r\n    return self:_IntoHash(false)\r\nend\r\n\r\nfunction Item:GetID()\r\n    return self.data.index\r\nend\r\n\r\nfunction Item:GetName()\r\n    return self.data.name\r\nend\r\n\r\nfunction Item:GetType()\r\n    return self.data.type\r\nend\r\n\r\nfunction Item:GetIcon()\r\n    return self.data.iconMUID\r\nend\r\n\r\nfunction Item:GetLevelRequirement()\r\n    return self.data.levelRequirement\r\nend\r\n\r\nfunction Item:GetRarity()\r\n    return self.data.rarity\r\nend\r\n\r\nfunction Item:IsEquippable()\r\n    return self.data.isEquippable\r\nend\r\n\r\nfunction Item:IsTwoHanded()\r\n    return self.SLOT_CONSTRAINTS[self:GetType()].isOffHandDisabled\r\nend\r\n\r\nfunction Item:IsBackpack()\r\n    return self.data.isBackpack\r\nend\r\n\r\nfunction Item:GetEquipSlotType()\r\n    if self:IsEquippable() then\r\n        return self.SLOT_CONSTRAINTS[self:GetType()].slotType\r\n    end\r\nend\r\n\r\nfunction Item:IsStackable()\r\n    return self.data.maxStackSize ~= nil\r\nend\r\n\r\nfunction Item:GetStackSize()\r\n    return self.stackSize\r\nend\r\n\r\nfunction Item:SetStackSize(stackSize)\r\n    assert(self:IsStackable() and stackSize >= 0)\r\n    self.stackSize = stackSize\r\nend\r\n\r\nfunction Item:GetMaxStackSize()\r\n    return self.data.maxStackSize\r\nend\r\n\r\nfunction Item:IsFullStack()\r\n    return self:GetStackSize() == self:GetMaxStackSize()\r\nend\r\n\r\nfunction Item:WillStackWith(otherItem)\r\n    return otherItem and \r\n    self:GetMUID() == otherItem:GetMUID() and \r\n    self:IsStackable()\r\nend\r\n\r\nfunction Item:GetAvailableStackSpace()\r\n    return self:GetMaxStackSize() - self:GetStackSize()\r\nend\r\n\r\nfunction Item:ApplyIconImageSettings(uiImage)\r\n    uiImage:SetImage(self.data.iconMUID)\r\n    uiImage:SetColor(self.data.iconColorTint or Color.WHITE)\r\n    uiImage.rotationAngle = self.data.iconRotation or 0\r\n    return self.data.iconMUID\r\nend\r\n\r\nfunction Item:GetMUID()\r\n    return self.data.muid\r\nend\r\n\r\nfunction Item:GetAnimationStance()\r\n    return self.data.stance\r\nend\r\n\r\nfunction Item:GetAbilityNames()\r\n    return self.data.abilityNames\r\nend\r\n\r\nfunction Item:GetDescription()\r\n    return self.data.description\r\nend\r\n\r\nfunction Item:GetStats()\r\n    print(CoreDebug.GetStackTrace())\r\n    warn(\"Item:GetStats() is deprecated for naming reasons. Use Item:GetStatsBase() instead.\")\r\n    return self.stats\r\nend\r\n\r\nfunction Item:HasStats()\r\n    return self.hasStats\r\nend\r\n\r\n-- Returns a table of the item\'s base stats.\r\nfunction Item:GetStatsBase()\r\n    return self.stats\r\nend\r\n\r\n-- Returns a table of the item\'s enhanced stats.\r\nfunction Item:GetStatsEnhanced()\r\n    return self.statsEnhanced\r\nend\r\n\r\nfunction Item:GetStatTotal(statName)\r\n    return self.statTotals[statName] or 0\r\nend\r\n\r\nfunction Item:GetSalvageComponents()\r\n    -- Returns a table containg salavage data of the item\r\n    -- {\r\n    --      componentItem = assetRef,\r\n    --      amount = int, \r\n    -- }\r\n    return self.data.salvageComponents\r\nend\r\n\r\nfunction Item:Clone()\r\n    local clone = Item.New(self.data, self:GetStackSize(), self:GetEnhancementLevel(), self:GetLimitBreakLevel())\r\n    clone:CopyStats(self)\r\n    return clone\r\nend\r\n\r\nfunction Item:CopyStats(other)\r\n    self.stats = {}\r\n    for i,stat in ipairs(other.stats) do\r\n        self.stats[i] = { name = other.stats[i].name, value = other.stats[i].value }\r\n    end\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:ClearStats()\r\n    self.stats = {}\r\nend\r\n\r\nfunction Item:RollStats()\r\n    self.stats = self.data:_RollStats()\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:HasConsumptionEffect()\r\n    return self:GetType() == \"Consumable\" and self.data.consumptionEffect ~= nil\r\nend\r\n\r\nfunction Item:ApplyConsumptionEffect(player)\r\n    if self.data.consumptionEffect then\r\n        require(self.data.consumptionEffect)(player)\r\n    end\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Enhancement API Methods\r\nfunction Item:GetEnhancementLevel()\r\n    return self.enhancementLevel\r\nend\r\n\r\nfunction Item:GetMaxEnhancementLevel()\r\n    return self.ENHANCEMENT_CAP * self:GetLimitBreakLevel()\r\nend\r\n\r\nfunction Item:SetEnhancementLevel(enhancementLevel)\r\n    assert(1 <= enhancementLevel and enhancementLevel <= self:GetMaxEnhancementLevel())\r\n    self.enhancementLevel = enhancementLevel\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:IsFullyEnhanced()\r\n    return self.enhancementLevel == self:GetMaxEnhancementLevel()\r\nend\r\n\r\nfunction Item:GetRequiredEnhancementItemName()\r\n    return self.data.enhancementItemName\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Limit-Break API Methods\r\n\r\nfunction Item:GetRequiredLimitBreakingItemName()\r\n    return self.data.limitBreakingItemName\r\nend\r\n\r\nfunction Item:GetLimitBreakLevel()\r\n    return self.limitBreakLevel\r\nend\r\n\r\nfunction Item:GetMaxLimitBreakLevel()\r\n    return self.LIMIT_BREAK_CAPS[self:GetRarity()]\r\nend\r\n\r\nfunction Item:SetLimitBreakLevel(limitBreakLevel)\r\n    assert(1 <= limitBreakLevel and limitBreakLevel <= self:GetMaxLimitBreakLevel())\r\n    self.limitBreakLevel = limitBreakLevel\r\nend\r\n\r\nfunction Item:IsFullyLimitBroken()\r\n    return self.limitBreakLevel == self:GetMaxLimitBreakLevel()\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Upgrade is a combination of enhancement and limit-break.\r\nfunction Item:IsNextUpgradeEnhancement()\r\n    return not self:IsFullyEnhanced()\r\nend\r\n\r\nfunction Item:IsNextUpgradeLimitBreak()\r\n    return self:IsFullyEnhanced() and not self:IsFullyLimitBroken()\r\nend\r\n\r\nfunction Item:CanUpgrade()\r\n    return self:HasStats() and \r\n    not (self:IsFullyEnhanced() and self:IsFullyLimitBroken())\r\n    and self:GetRequiredLimitBreakingItemName()\r\n    and self:GetRequiredEnhancementItemName()\r\nend\r\n\r\nfunction Item:Upgrade()\r\n    if self:IsNextUpgradeEnhancement() then\r\n        self:SetEnhancementLevel(self:GetEnhancementLevel() + 1)\r\n    elseif self:IsNextUpgradeLimitBreak() then\r\n        self:SetLimitBreakLevel(self:GetLimitBreakLevel() + 1)\r\n        self:SetEnhancementLevel(self:GetEnhancementLevel() + 1)\r\n    end\r\n    self:_RecalculateStatTotals()\r\nend\r\n---------------------------------------------------------------------------------------------------------\r\n-- PRIVATE\r\n---------------------------------------------------------------------------------------------------------\r\nlocal HASH_RUNTIME = \"R\"\r\nlocal HASH_PERSISTENT = \"P\"\r\nlocal HASH_DELIM_INTRO = \"|\"\r\nlocal HASH_DELIM_SUBINV = \">\"\r\nlocal HASH_DELIM_STAT_BASE = \"#\"\r\nlocal HASH_DELIM_STAT_BONUS = \"&\"\r\nlocal HASH_DELIM_STAT_EQUALS = \"=\"\r\nlocal HASH_PATTERN_FULL = \"^(.*)|(.*)|(.*)|(.*)|(.*)|(.*)$\"\r\nlocal HASH_PATTERN_STAT = \"([#&])([^#&=]+)=(....)\"\r\nlocal HASH_INVENTORY_PATTERN = \"<([^<>;]+)>([^<>;]+)<([^<>;]+)>;\"\r\n\r\nfunction Item._StatInfo(statInfo)\r\n    assert(statInfo.name, \"stat info missing name\")\r\n    assert(statInfo.value, \"stat info missing value\")\r\n    assert(statInfo.isBase or statInfo.isBonus, \"stat must be either base or bonus\")\r\n    return statInfo\r\nend\r\n\r\nfunction Item:_Init(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    self.data = itemData\r\n    self.stackSize = stackSize or 1\r\n    self.enhancementLevel = enhancementLevel or 1\r\n    self.limitBreakLevel = limitBreakLevel or 1\r\n    self.stats = {}\r\n    self.statTotals = {}\r\n    self.backpackInventory = nil\r\nend\r\n\r\nfunction Item:_IntoHash(isRuntime)\r\n    local hashParts = {}\r\n    table.insert(hashParts, isRuntime and HASH_RUNTIME or HASH_PERSISTENT)\r\n    table.insert(hashParts, isRuntime and Base64.Encode24(self.data.index) or self.data.muid)\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    if Item.ALLOW_LARGE_STACK_SIZES then\r\n        table.insert(hashParts, Base64.Encode24(self:GetStackSize()))\r\n    else\r\n        table.insert(hashParts, Base64.Encode12(self:GetStackSize()))\r\n    end\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    table.insert(hashParts, Base64.Encode6(self:GetEnhancementLevel()))\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    table.insert(hashParts, Base64.Encode6(self:GetLimitBreakLevel()))\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    if self.stats ~= nil then\r\n        for _,stat in ipairs(self.stats) do\r\n            local statIndex = self.STATS[stat.name]\r\n            local statDelimiter = stat.isBase and HASH_DELIM_STAT_BASE or HASH_DELIM_STAT_BONUS\r\n            local statKey = isRuntime and Base64.Encode6(statIndex) or stat.name\r\n            local statValue = Base64.Encode24(stat.value)\r\n            table.insert(hashParts, statDelimiter)\r\n            table.insert(hashParts, statKey)\r\n            table.insert(hashParts, HASH_DELIM_STAT_EQUALS)\r\n            table.insert(hashParts, statValue)\r\n        end\r\n    end\r\n\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    local subItemCount = 0\r\n    if self:IsBackpack() then\r\n        local backpackInventory = self:GetBackpackInventory()\r\n        if backpackInventory and self:IsBackpack() then\r\n            for i, item in backpackInventory:IterateEntireInventory() do\r\n                if item then\r\n                    subItemCount = subItemCount + 1\r\n                end\r\n            end\r\n        end\r\n        local inventoryHash = isRuntime and HASH_RUNTIME or HASH_PERSISTENT\r\n        if backpackInventory and isRuntime then\r\n            inventoryHash = backpackInventory:RuntimeHash()\r\n        elseif backpackInventory then\r\n            inventoryHash = backpackInventory:PersistentHash()\r\n        end\r\n        table.insert(hashParts, string.format(\"<%i>\", subItemCount))\r\n        table.insert(hashParts, \";\")\r\n        table.insert(hashParts, inventoryHash:sub(2))\r\n    else\r\n        table.insert(hashParts, string.format(\"<%i>\", subItemCount))\r\n    end\r\n    return table.concat(hashParts)\r\nend\r\n\r\nfunction Item._FromHash(database, hash)\r\n    local hashType = hash:sub(1, 1)\r\n    local hashData = hash:sub(2)\r\n    local isRuntime = hashType == HASH_RUNTIME\r\n    local hashItemId, hashStackSize, hashEnhancementLevel, hashLimitBreakLevel, hashItemStats, backpackSubHash = hashData:match(HASH_PATTERN_FULL)\r\n    local itemData = nil\r\n    if isRuntime then\r\n        itemData = database:FindItemDataByIndex(Base64.Decode24(hashItemId))\r\n    else\r\n        itemData = database:FindItemDataByMUID(hashItemId)\r\n    end\r\n    if not itemData then\r\n        warn(\"unable to locate item data for hash: \", hashData)\r\n        return\r\n    end\r\n\r\n\r\n    local stackSize = 0\r\n    if Item.ALLOW_LARGE_STACK_SIZES then\r\n        -- Decode12 -> Decode24\r\n        if string.len(hashStackSize) == 2 then\r\n            stackSize = hashStackSize and Base64.Decode12(hashStackSize) or nil\r\n            hashStackSize = Base64.Encode24(stackSize) -- Convert 12 to 24\r\n        end\r\n        -- 2^24 = 16777216 max stack size.\r\n        stackSize = hashStackSize and Base64.Decode24(hashStackSize) or nil\r\n    else\r\n        -- Decode24 -> Decode12 ( With limits considered )\r\n        if string.len(hashStackSize) == 4 then\r\n            stackSize = hashStackSize and Base64.Decode24(hashStackSize) or nil\r\n            if stackSize > 2^12 then\r\n                warn(string.format(\"Allow large stack size custom property on ItemSystems_Item was turned off while there was items that exceeded 2^12 in stack size. Reducing the stack size to maxmium amount allowable by the item - %s\",itemData.name))\r\n                if itemData.maxStackSize > 2^12 then\r\n                    stackSize = 2^12\r\n                else\r\n                    stackSize = itemData.maxStackSize\r\n                end\r\n            end\r\n            hashStackSize = Base64.Encode12(stackSize) -- Convert 24 to 12\r\n        end\r\n        -- 2^12 = 4096 max stack size.\r\n        stackSize = hashStackSize and Base64.Decode12(hashStackSize) or nil\r\n    end\r\n\r\n    local enhancementLevel = hashEnhancementLevel and Base64.Decode6(hashEnhancementLevel) or nil\r\n    local limitBreakLevel = hashLimitBreakLevel and Base64.Decode6(hashLimitBreakLevel) or nil\r\n    local item = Item.New(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    for statDelimiter,statNameHash,statValueHash in hashItemStats:gmatch(HASH_PATTERN_STAT) do\r\n        local statIsBase = statDelimiter == HASH_DELIM_STAT_BASE or nil\r\n        local statName = isRuntime and Item.STATS[Base64.Decode6(statNameHash)] or statNameHash\r\n        local statValue = Base64.Decode24(statValueHash)\r\n        local statInfo = Item._StatInfo{ \r\n            name = statName,\r\n            value = statValue,\r\n            isBase = statIsBase or nil,\r\n            isBonus = not statIsBase or nil,\r\n        }\r\n        table.insert(item.stats, statInfo)\r\n    end\r\n    item:_RecalculateStatTotals()\r\n    return item\r\nend\r\n\r\nfunction Item:_RecalculateStatTotals()\r\n    if self.stats == nil then return end\r\n\r\n    -- Clear old values.\r\n    for _,statName in ipairs(Item.STATS) do \r\n        self.statTotals[statName] = 0 \r\n    end\r\n\r\n    -- Compute enhanced stats.\r\n    local enhancementMultiplier = self:_GetEnhancementMultiplier()\r\n    self.statsEnhanced = {}\r\n    for i,stat in ipairs(self.stats) do\r\n        self.statsEnhanced[i] = {\r\n            name = stat.name,\r\n            isBase = stat.isBase,\r\n            value = math.floor(0.5 + stat.value * enhancementMultiplier),\r\n        }\r\n    end\r\n\r\n    -- Sum stats to get stat totals (effective and base).\r\n    self.hasStats = nil\r\n    for i,stat in ipairs(self.statsEnhanced) do\r\n        self.hasStats = true\r\n        self.statTotals[stat.name] = self.statTotals[stat.name] + stat.value\r\n    end\r\nend\r\n\r\nfunction Item:_GetEnhancementMultiplier()\r\n    return 1 + (math.max(0, self:GetEnhancementLevel() - 1) * self.ENHANCEMENT_STAT_PERCENT_INCREASE / 100)\r\nend\r\n\r\nfunction Item:__tostring()\r\n    local s = {}\r\n    table.insert(s, \"ITEM:\\n\")\r\n    table.insert(s, string.format(\"\\tname:   %s\\n\", self.data.name))\r\n    table.insert(s, string.format(\"\\trarity: %s\\n\", self.data.rarity))\r\n    table.insert(s, string.format(\"\\tenhancement: %s\\n\", self:GetEnhancementLevel()))\r\n    table.insert(s, string.format(\"\\tlimitBreaks: %s\\n\", self:GetLimitBreakLevel()))\r\n    if self.stats then\r\n        for _,stat in ipairs(self.stats) do\r\n            local statType = stat.isBase and \"BASE\" or \"BONUS\"\r\n            table.insert(s, string.format(\"\\tstat:   %-5s %-9s %d\\n\", statType, stat.name, stat.value))\r\n        end\r\n    end\r\n    table.insert(s, string.format(\"\\thash-R: %s\\n\", self:RuntimeHash()))\r\n    table.insert(s, string.format(\"\\thash-P: %s\\n\", self:PersistentHash()))\r\n    return table.concat(s)\r\nend\r\n---------------------------------------------------------------------------------------------------------\r\nreturn Item"
        CustomParameters {
          Overrides {
            Name: "cs:Base64"
            AssetReference {
              Id: 3976507683543157652
            }
          }
          Overrides {
            Name: "cs:AllowLargeStacksizes"
            Bool: true
          }
          Overrides {
            Name: "cs:AllowLargeStacksizes:tooltip"
            String: "When enabled the inventory will support the largest stack size that is supported by Base64. The drawback to having a larger stack size is a loss of some comprehension."
          }
        }
      }
    }
    Assets {
      Id: 3976507683543157652
      Name: "Base64"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Base64\r\n    ====================\r\n    This library is used by the Item system to transform data into a shorter length of that data so it\'s easy on the network and\r\n    for storage.\r\n]]\r\n\r\nlocal Base64 = {}\r\n\r\n-- Lookup tables for fast encode/decode.\r\nlocal SYMBOLS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-+\"\r\nlocal REVERSE = {}\r\nfor i=1,#SYMBOLS do\r\n    local c = SYMBOLS:sub(i, i)\r\n    REVERSE[c] = i - 1\r\nend\r\n-- This is useful for anyone wanting to know some other characters can still be used as protocol markers.\r\nlocal UNUSED_SYMBOLS = \"?!@#$%^&*={}[]()<>,.\"\r\n\r\n-- Store these in the class for anyone else who needs them.\r\nBase64.MATCH_PATTERN = \"[%a%d%-%+]\"\r\nBase64.UNUSED_SYMBOLS = UNUSED_SYMBOLS\r\nBase64.SYMBOLS = SYMBOLS\r\nBase64.REVERSE = REVERSE\r\n\r\n-- More useful constants so you know what you can and can\'t encode.\r\nBase64.MAX_6 = 2^6 - 1\r\nBase64.MAX_12 = 2^12 - 1\r\nBase64.MAX_24 = 2^24 - 1\r\n\r\n-- Helper for encoding.\r\nfunction raw_encode_6(uint6)\r\n    return SYMBOLS:sub(uint6+1, uint6+1)\r\nend\r\n\r\n-- Encode a 6 bit value into a character.\r\nfunction Base64.Encode6(uint6)\r\n    assert(0 <= uint6 and uint6 <= Base64.MAX_6)\r\n    return raw_encode_6(uint6)\r\nend\r\n\r\n-- Encode a 12 bit value into a string of two characters.\r\nfunction Base64.Encode12(uint12)\r\n    assert(0 <= uint12 and uint12 <= Base64.MAX_12)\r\n    local en = raw_encode_6\r\n    local b1 = en(0x3F & (uint12 >> 0))\r\n    local b2 = en(0x3F & (uint12 >> 6))\r\n    return b1 .. b2\r\nend\r\n\r\n-- Encode a 24 bit value into a string of two characters.\r\nfunction Base64.Encode24(uint24)\r\n    assert(0 <= uint24 and uint24 <= Base64.MAX_24)\r\n    local en = raw_encode_6\r\n    local b1 = en(0x3F & (uint24 >> 0))\r\n    local b2 = en(0x3F & (uint24 >> 6))\r\n    local b3 = en(0x3F & (uint24 >> 12))\r\n    local b4 = en(0x3F & (uint24 >> 18))\r\n    return b1 .. b2 .. b3 .. b4\r\nend\r\n\r\n-- Decode the next 6 bit value from the base64 string.\r\nfunction Base64.Decode6(s)\r\n    return REVERSE[s:sub(1, 1)]\r\nend\r\n\r\n-- Decode the next 12 bit value from the base64 string.\r\nfunction Base64.Decode12(s)\r\n    local sub = string.sub\r\n    local b1 = REVERSE[sub(s, 1, 1)]\r\n    local b2 = REVERSE[sub(s, 2, 2)]\r\n    return b1 | (b2 << 6)\r\nend\r\n\r\n-- Decode the next 24 bit value from the base64 string.\r\nfunction Base64.Decode24(s)\r\n    local sub = string.sub\r\n    local b1 = REVERSE[sub(s, 1, 1)]\r\n    local b2 = REVERSE[sub(s, 2, 2)]\r\n    local b3 = REVERSE[sub(s, 3, 3)]\r\n    local b4 = REVERSE[sub(s, 4, 4)]\r\n    return b1 | (b2 << 6) | (b3 << 12) | (b4 << 18)\r\nend\r\n\r\n-- Sanity check.\r\nfunction Base64._SelfTest()\r\n    assert(\"a\" == Base64.Encode6(0))\r\n    assert(\"+\" == Base64.Encode6(63))\r\n    assert(0 == Base64.Decode6(\"a\"))\r\n    assert(63 == Base64.Decode6(\"+\"))\r\n\r\n    assert(\"aa\" == Base64.Encode12(0))\r\n    assert(\"+a\" == Base64.Encode12(63))\r\n    assert(\"a+\" == Base64.Encode12(4032))\r\n    assert(\"++\" == Base64.Encode12(4095))\r\n    assert(0 == Base64.Decode12(\"aa\"))\r\n    assert(63 == Base64.Decode12(\"+a\"))\r\n    assert(4032 == Base64.Decode12(\"a+\"))\r\n    assert(4095 == Base64.Decode12(\"++\"))\r\n\r\n    assert(\"+aaa\" == Base64.Encode24(63))\r\n    assert(\"a+aa\" == Base64.Encode24(4032))\r\n    assert(\"aa+a\" == Base64.Encode24(258048))\r\n    assert(\"aaa+\" == Base64.Encode24(16515072))\r\n    assert(63 == Base64.Decode24(\"+aaa\"))\r\n    assert(4032 == Base64.Decode24(\"a+aa\"))\r\n    assert(258048 == Base64.Decode24(\"aa+a\"))\r\n    assert(16515072 == Base64.Decode24(\"aaa+\"))\r\nend\r\nBase64._SelfTest()\r\n\r\nreturn Base64"
      }
    }
    Assets {
      Id: 16947512388630727784
      Name: "ItemSystems_RollerTemplate"
      PlatformAssetType: 5
      TemplateAsset {
        ObjectBlock {
          RootId: 1898839101549228227
          Objects {
            Id: 1898839101549228227
            Name: "Roller"
            Transform {
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 17914490041441623834
            UnregisteredParameters {
              Overrides {
                Name: "cs:PlayerName"
                String: ""
              }
              Overrides {
                Name: "cs:Rolled"
                Int: 0
              }
              Overrides {
                Name: "cs:PlayerName:isrep"
                Bool: true
              }
              Overrides {
                Name: "cs:Rolled:isrep"
                Bool: true
              }
            }
            WantsNetworking: true
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Folder {
              IsGroup: true
            }
          }
        }
        PrimaryAssetId {
          AssetType: "None"
          AssetId: "None"
        }
      }
    }
    Assets {
      Id: 14475141008376894138
      Name: "ReliableEvents"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Deque = require(script:GetCustomProperty(\"Deque\"))\r\n\r\nlocal txQueue = Deque.New()\r\n\r\nfunction Retry()\r\n    while not txQueue:Empty() do\r\n        local method = txQueue:Front().method\r\n        local broadcast = Events[method]\r\n        local result = broadcast(table.unpack(txQueue:Front()))\r\n        if result ~= BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n            txQueue:PopFront()\r\n        else\r\n            Task.Wait(1)\r\n        end\r\n    end\r\nend\r\n\r\nlocal ReliableEvents = {}\r\n\r\nfunction ReliableEvents.BroadcastToServer(...)\r\n    txQueue:PushBack({ method = \"BroadcastToServer\", ... })\r\n    Retry()\r\nend\r\n\r\nfunction ReliableEvents.BroadcastToPlayer(...)\r\n    txQueue:PushBack({ method = \"BroadcastToPlayer\", ... })\r\n    Retry()\r\nend\r\n\r\nfunction ReliableEvents.BroadcastToAllPlayers(...)\r\n    txQueue:PushBack({ method = \"BroadcastToAllPlayers\", ... })\r\n    Retry()  \r\nend\r\n\r\nlocal txTask = Task.Spawn(function() Retry() end)\r\n\r\nreturn ReliableEvents"
        CustomParameters {
          Overrides {
            Name: "cs:Deque"
            AssetReference {
              Id: 13065009035227440427
            }
          }
        }
      }
    }
    Assets {
      Id: 13065009035227440427
      Name: "Deque"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    Deque\r\n    A double ended queue object.\r\n--]]\r\n\r\nlocal Deque = {}\r\nDeque.__index = Deque\r\n\r\nfunction Deque.New()\r\n    local deque = {}\r\n    setmetatable(deque, Deque)\r\n    deque:Clear()\r\n    return deque\r\nend\r\n\r\nfunction Deque:Clear()\r\n    self.front = 0\r\n    self.back = -1\r\nend\r\n\r\nfunction Deque:Empty()\r\n    return self.front > self.back\r\nend\r\n\r\nfunction Deque:Count()\r\n    if not self:Empty() then return self.back - self.front + 1 else return 0 end\r\nend\r\n\r\nfunction Deque:PushBack(value)\r\n    self.back = self.back + 1\r\n    self[self.back] = value\r\nend\r\n\r\nfunction Deque:PushFront(value)\r\n    self.front = self.front - 1\r\n    self[self.front] = value\r\nend\r\n\r\nfunction Deque:Front()\r\n    if not self:Empty() then return self[self.front] end\r\nend\r\n\r\nfunction Deque:Back()\r\n    if not self:Empty() then return self[self.back] end\r\nend\r\n\r\nfunction Deque:PopBack()\r\n    if not self:Empty() then\r\n        local val = self[self.back]\r\n        self.back = self.back - 1\r\n        return val\r\n    end\r\nend\r\n\r\nfunction Deque:PopFront()\r\n    if not self:Empty() then\r\n        local val = self[self.front]\r\n        self.front = self.front + 1\r\n        return val\r\n    end\r\nend\r\n\r\nfunction Deque._SelfTest()\r\n    local d = Deque.New()\r\n    assert(d:Empty())\r\n    local vals = {1, 2, 3, 4}\r\n    for _,v in ipairs(vals) do d:PushBack(v) end\r\n    assert(d:Count() == #vals)\r\n    assert(d:Front() == vals[1])\r\n    assert(d:Back() == vals[#vals])\r\n    for _,v in ipairs(vals) do assert(d:PopFront() == v) end\r\n    assert(d:Count() == 0) \r\n    for _,v in ipairs(vals) do d:PushFront(v) end\r\n    assert(d:Count() == #vals)\r\n    assert(d:Front() == vals[#vals])\r\n    assert(d:Back() == vals[1])\r\n    for _,v in ipairs(vals) do assert(d:PopBack() == v) end\r\n    assert(d:Count() == 0) \r\nend\r\n\r\nDeque._SelfTest()\r\n\r\nreturn Deque"
      }
    }
    Assets {
      Id: 18417580940993918629
      Name: "ItemSystems_RollEntry"
      PlatformAssetType: 5
      TemplateAsset {
        ObjectBlock {
          RootId: 17830932276479654842
          Objects {
            Id: 17830932276479654842
            Name: "ItemSystems_RollEntry"
            Transform {
              Scale {
                X: 1
                Y: 1
                Z: 1
              }
            }
            ParentId: 4781671109827199097
            UnregisteredParameters {
              Overrides {
                Name: "cs:ItemHash"
                String: ""
              }
              Overrides {
                Name: "cs:RequestedPlayers"
                String: ""
              }
              Overrides {
                Name: "cs:ID"
                Int: 0
              }
              Overrides {
                Name: "cs:ItemHash:isrep"
                Bool: true
              }
              Overrides {
                Name: "cs:RequestedPlayers:isrep"
                Bool: true
              }
              Overrides {
                Name: "cs:ID:isrep"
                Bool: true
              }
            }
            WantsNetworking: true
            Collidable_v2 {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Visible_v2 {
              Value: "mc:evisibilitysetting:inheritfromparent"
            }
            CameraCollidable {
              Value: "mc:ecollisionsetting:inheritfromparent"
            }
            Folder {
              IsGroup: true
            }
          }
        }
        PrimaryAssetId {
          AssetType: "None"
          AssetId: "None"
        }
      }
    }
  }
  SerializationVersion: 84
}
