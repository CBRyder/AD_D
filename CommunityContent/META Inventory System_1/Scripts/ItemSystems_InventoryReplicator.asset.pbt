Assets {
  Id: 5043088254156687776
  Name: "ItemSystems_InventoryReplicator"
  PlatformAssetType: 3
  TextAsset {
    CustomParameters {
      Overrides {
        Name: "cs:ItemSystems_Database"
        AssetReference {
          Id: 8583392859467906295
        }
      }
      Overrides {
        Name: "cs:ItemSystems_Inventory"
        AssetReference {
          Id: 7726054879166818000
        }
      }
      Overrides {
        Name: "cs:ReliableEvents"
        AssetReference {
          Id: 14475141008376894138
        }
      }
      Overrides {
        Name: "cs:InventoryComponent"
        ObjectReference {
        }
      }
      Overrides {
        Name: "cs:SharedStorageKey"
        NetReference {
          Type {
            Value: "mc:enetreferencetype:unknown"
          }
        }
      }
      Overrides {
        Name: "cs:SharedStorageKey:tooltip"
        String: "When assigned with a share storage key then the player\'s inventory can be shared across multiple games that use the same key."
      }
    }
    Assets {
      Id: 14475141008376894138
      Name: "ReliableEvents"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Deque = require(script:GetCustomProperty(\"Deque\"))\r\n\r\nlocal txQueue = Deque.New()\r\n\r\nfunction Retry()\r\n    while not txQueue:Empty() do\r\n        local method = txQueue:Front().method\r\n        local broadcast = Events[method]\r\n        local result = broadcast(table.unpack(txQueue:Front()))\r\n        if result ~= BroadcastEventResultCode.EXCEEDED_RATE_LIMIT then\r\n            txQueue:PopFront()\r\n        else\r\n            Task.Wait(1)\r\n        end\r\n    end\r\nend\r\n\r\nlocal ReliableEvents = {}\r\n\r\nfunction ReliableEvents.BroadcastToServer(...)\r\n    txQueue:PushBack({ method = \"BroadcastToServer\", ... })\r\n    Retry()\r\nend\r\n\r\nfunction ReliableEvents.BroadcastToPlayer(...)\r\n    txQueue:PushBack({ method = \"BroadcastToPlayer\", ... })\r\n    Retry()\r\nend\r\n\r\nfunction ReliableEvents.BroadcastToAllPlayers(...)\r\n    txQueue:PushBack({ method = \"BroadcastToAllPlayers\", ... })\r\n    Retry()  \r\nend\r\n\r\nlocal txTask = Task.Spawn(function() Retry() end)\r\n\r\nreturn ReliableEvents"
        CustomParameters {
          Overrides {
            Name: "cs:Deque"
            AssetReference {
              Id: 13065009035227440427
            }
          }
        }
      }
    }
    Assets {
      Id: 13065009035227440427
      Name: "Deque"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    Deque\r\n    A double ended queue object.\r\n--]]\r\n\r\nlocal Deque = {}\r\nDeque.__index = Deque\r\n\r\nfunction Deque.New()\r\n    local deque = {}\r\n    setmetatable(deque, Deque)\r\n    deque:Clear()\r\n    return deque\r\nend\r\n\r\nfunction Deque:Clear()\r\n    self.front = 0\r\n    self.back = -1\r\nend\r\n\r\nfunction Deque:Empty()\r\n    return self.front > self.back\r\nend\r\n\r\nfunction Deque:Count()\r\n    if not self:Empty() then return self.back - self.front + 1 else return 0 end\r\nend\r\n\r\nfunction Deque:PushBack(value)\r\n    self.back = self.back + 1\r\n    self[self.back] = value\r\nend\r\n\r\nfunction Deque:PushFront(value)\r\n    self.front = self.front - 1\r\n    self[self.front] = value\r\nend\r\n\r\nfunction Deque:Front()\r\n    if not self:Empty() then return self[self.front] end\r\nend\r\n\r\nfunction Deque:Back()\r\n    if not self:Empty() then return self[self.back] end\r\nend\r\n\r\nfunction Deque:PopBack()\r\n    if not self:Empty() then\r\n        local val = self[self.back]\r\n        self.back = self.back - 1\r\n        return val\r\n    end\r\nend\r\n\r\nfunction Deque:PopFront()\r\n    if not self:Empty() then\r\n        local val = self[self.front]\r\n        self.front = self.front + 1\r\n        return val\r\n    end\r\nend\r\n\r\nfunction Deque._SelfTest()\r\n    local d = Deque.New()\r\n    assert(d:Empty())\r\n    local vals = {1, 2, 3, 4}\r\n    for _,v in ipairs(vals) do d:PushBack(v) end\r\n    assert(d:Count() == #vals)\r\n    assert(d:Front() == vals[1])\r\n    assert(d:Back() == vals[#vals])\r\n    for _,v in ipairs(vals) do assert(d:PopFront() == v) end\r\n    assert(d:Count() == 0) \r\n    for _,v in ipairs(vals) do d:PushFront(v) end\r\n    assert(d:Count() == #vals)\r\n    assert(d:Front() == vals[#vals])\r\n    assert(d:Back() == vals[1])\r\n    for _,v in ipairs(vals) do assert(d:PopBack() == v) end\r\n    assert(d:Count() == 0) \r\nend\r\n\r\nDeque._SelfTest()\r\n\r\nreturn Deque"
      }
    }
    Assets {
      Id: 7726054879166818000
      Name: "ItemSystems_Inventory"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Inventory\r\n    ====================\r\n    Logical representation of an inventory that contains numerous methods that allow you to manage\r\n    the players inventory. Please refer to the ItemSystems_README for detailed information.\r\n]]\r\nlocal Item = require(script:GetCustomProperty(\"ItemSystems_Item\"))\r\nlocal UpgradesCostBasis = require(script:GetCustomProperty(\"ItemSystems_UpgradesCostBasis\"))\r\nlocal Base64 = require(script:GetCustomProperty(\"Base64\"))\r\n\r\nlocal Inventory = {}\r\nInventory.__index = Inventory\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- CONSTANTS\r\n---------------------------------------------------------------------------------------------------------\r\nlocal function Enum(values) for i,v in ipairs(values) do values[v] = i end end\r\n\r\n-- When enabled on the script it will allow the client to drop items into the world without trashing the item.\r\nInventory.DROP_ITEM_INSTEAD_OF_DELETE = script:GetCustomProperty(\"DropItemInsteadOfDelete\")\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PUBLIC\r\n---------------------------------------------------------------------------------------------------------\r\n\r\n-- Inventory Constructor\r\nfunction Inventory.New(database, owner, backpackSize, equipSlots)\r\n    local o = {}\r\n    setmetatable(o, Inventory)\r\n    o.EQUIP_SLOTS = not equipSlots and {} or equipSlots\r\n    o.BACKPACK_CAPACITY = backpackSize or 32\r\n    o.TOTAL_CAPACITY = #o.EQUIP_SLOTS + o.BACKPACK_CAPACITY\r\n    assert(o.TOTAL_CAPACITY <= 64, \"inventory size limit is 64 for compression reasons\")\r\n    o:_Init(database, owner)\r\n    o:_DefineEvent(\"lootClaimedEvent\")\r\n    o:_DefineEvent(\"itemEquippedEvent\")\r\n    o:_DefineEvent(\"itemUnequippedEvent\")\r\n    o:_DefineEvent(\"itemMovedEvent\")\r\n    o:_DefineEvent(\"itemConsumedEvent\")\r\n    o:_DefineEvent(\"itemDropEvent\")\r\n    o:_DefineEvent(\"itemAdded\")\r\n    o:_DefineEvent(\"itemSetToSlot\")\r\n    o:_DefineEvent(\"itemRemoved\")\r\n    o:_DefineEvent(\"itemRemoveByPercentage\")\r\n    o:_DefineEvent(\"itemRemoveAll\")\r\n    o:_DefineEvent(\"itemSalvage\")\r\n    o:_DefineEvent(\"itemUpgradedEvent\")\r\n    o:_DefineEvent(\"craftExecutedEvent\")\r\n    o:_DefineEvent(\"backpackRemoved\")\r\n    o:_DefineEvent(\"SetLockAbilities\")\r\n    o:_DefineEvent(\"OnInventoryChanged\")\r\n    return o\r\nend\r\n\r\n-- Load an inventory hash onto the inventory.\r\nfunction Inventory:LoadHash(hash)\r\n    self:_ClearSlots()\r\n    if hash then\r\n        self:_LoadHash(hash)\r\n    end\r\n    self.hasLoaded = true\r\nend\r\n\r\n-- Wait until the inventory hash has loaded.\r\nfunction Inventory:WaitUntilLoaded()\r\n    while not self.hasLoaded do \r\n        Task.Wait() \r\n    end\r\nend\r\n\r\n------------------------------------------------------------------------------------------------\r\n-- Inventory Management Methods\r\n------------------------------------------------------------------------------------------------\r\n-- These methods can be called on either the client or server and it will sync with the opposite context.\r\n-- Use get methods from ItemSystems_Database to get construct items and pass them into these functions when needed.\r\n-- The purpose of _hasRepeated is to prevent an infinite context loop since the methods commuinciate to the opposite context.\r\n\r\n-- Adds an item to the backpack. With an optional quantity.\r\nfunction Inventory:AddItem(item, quantity, _hasRepeated) -- item, int, bool (ignore)\r\n    assert(item:GetName(),string.format(\"%s is not of type ItemSystems_Item. Use the item database to create an item then call this method with your item.\",item))\r\n    local storedQuantity = quantity or 1\r\n    local emptySlotIndex = self:GetFreeBackpackSlot()\r\n    if item:IsStackable() then\r\n        quantity = quantity or 1\r\n        item:SetStackSize(quantity)\r\n        self:_AddItemToBackpack(item)\r\n    elseif item:IsBackpack() then\r\n        item:ClearStats()\r\n        item:NewBackpackInventory(Inventory,self.database,self.owner,item:RuntimeHash())\r\n        self:_AddItemToBackpack(item)\r\n    elseif emptySlotIndex then\r\n        self:_SetSlotItem(emptySlotIndex, item) \r\n    end\r\n    if not _hasRepeated then -- Prevents an infinite context loop.\r\n        -- Replicate the state of the inventory to either client or server.\r\n        self:_FireEvent(\"itemAdded\",item:RuntimeHash(),storedQuantity)\r\n    end\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Sets a slot in the inventory to have an item\r\nfunction Inventory:SetItemToSlot(item,quantity,slot,_hasRepeated) -- Item item, int quantity, int slot, bool _hasRepeated (ignore)\r\n    assert(item:GetName(),string.format(\"%s is not of type ItemSystems_Item. Use the item database to create an item then call this method with your item.\",item))\r\n    local storedQuantity = quantity or 1\r\n    if item:IsStackable() then\r\n        item:SetStackSize(quantity)\r\n    end\r\n    if item:IsBackpack() then\r\n        item:ClearStats()\r\n        item:NewBackpackInventory(Inventory,self.database,self.owner,item:RuntimeHash())\r\n        self:_AddItemToBackpack(item)\r\n    end\r\n    self:_SetSlotItem(slot, item)\r\n    if not _hasRepeated then -- Prevents an infinite context loop.\r\n        -- Replicate the state of the inventory to either client or server.\r\n        self:_FireEvent(\"itemSetToSlot\",item:RuntimeHash(),storedQuantity,slot)\r\n    end\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Remove an item from the inventory with an optional quantity\r\nfunction Inventory:RemoveItem(item, quantity, _hasRepeated) -- Item item, int quantity (optional), bool (ignore)\r\n    assert(item:GetName(),string.format(\"%s is not of type ItemSystems_Item. Use the item database to create an item then call this method with your item.\",item))\r\n    local storedQuantity = (quantity ~= nil and quantity > 0) and quantity or 1\r\n    local hasItem, slotIndex, _ = self:HasItem(item)\r\n    if hasItem and item:IsStackable() then\r\n        item:SetStackSize(storedQuantity)\r\n        self:_RemoveItemFromBackpack(item)\r\n    else\r\n        self:_SetSlotItem(slotIndex, nil)\r\n    end\r\n    if not _hasRepeated then -- Prevents an infinite context loop.\r\n        -- Replicate the state of the inventory to either client or server.\r\n        self:_FireEvent(\"itemRemoved\",item:RuntimeHash(),storedQuantity)\r\n    end\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Removes everything from the inventory\r\nfunction Inventory:RemoveAllItems(_hasRepeated) -- bool _hasRepeated (ignore)\r\n    self:LoadHash(\"R\")\r\n    if not _hasRepeated then -- Prevents an infinite context loop.\r\n        self:_FireEvent(\"itemRemoveAll\",self.owner)\r\n    end\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Removes a percentage of items from the inventory\r\nfunction Inventory:RemoveItemsByPercentage(percent,_seed,_hasRepeated) -- int percent( 1 - 100 ), int _seed (Ignore), bool _hasRepeated (Ignore)\r\n    assert(percent > 0 and percent <= 100, string.format(\"provided percentage is not valid. - %d\",percent))\r\n    local itemsSum = self:GetItemsSum()\r\n    local items = self:GetAllItems()\r\n    local itemsToRemove = math.ceil(itemsSum*(percent/100))\r\n    local seed = _seed or os.time()\r\n    local function RemoveItems_R(items,removeAmount,seed)\r\n        Task.Wait()\r\n        math.randomseed(seed)\r\n        if #items == 0 then return end\r\n        local itemIndex = math.random(1,#items)\r\n        local randomItem = items[itemIndex].item\r\n        local randomSlot = items[itemIndex].slot\r\n        if randomItem:IsStackable() then\r\n            local randomAmount\r\n            randomAmount = math.random(1,randomItem:GetStackSize())\r\n            removeAmount = CoreMath.Clamp(removeAmount - randomAmount,0,math.huge)\r\n            local newItem = self.database:GetItemFromName(randomItem:GetName())\r\n            newItem:SetStackSize(randomAmount)\r\n            if newItem:GetStackSize() == randomItem:GetStackSize() then\r\n                table.remove(items,itemIndex)\r\n                self:_RemoveItemFromBackpack(newItem)\r\n            elseif removeAmount <= 1 then\r\n                table.remove(items,itemIndex)\r\n                self:_SetSlotItem(randomSlot,nil)\r\n            end\r\n        else\r\n            removeAmount = removeAmount - 1\r\n            table.remove(items,itemIndex)\r\n            self:_SetSlotItem(randomSlot,nil)\r\n        end\r\n        if removeAmount > 0 then\r\n            RemoveItems_R(items,removeAmount,seed+1)\r\n        end\r\n    end\r\n    RemoveItems_R(items,itemsToRemove,seed)\r\n    if not _hasRepeated then -- Prevents an infinite context loop.\r\n        -- Replicate the state of the inventory to either client or server.\r\n        self:_FireEvent(\"itemRemoveByPercentage\",percent,seed)\r\n    end\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n\r\n-- Returns true if the the inventory has the item and a slotindex of the item in the inventory. Returns nil if nothing is found.\r\nfunction Inventory:HasItem(item,quantity) -- item, int\r\n    quantity = quantity or 1\r\n    for i, inventoryItem in self:IterateEntireInventory() do\r\n        if inventoryItem and inventoryItem:GetMUID() == item:GetMUID() and self:GetItemStackSum(inventoryItem) >= quantity then\r\n            return true, i, self:GetItemStackSum(inventoryItem)\r\n        end\r\n    end\r\n    return false, nil, 0\r\nend\r\n\r\n-- Returns the sum of all the stacks of a particular item\r\nfunction Inventory:GetItemStackSum(item) -- item\r\n    local stackSize = 0\r\n    for i, inventoryItem in self:IterateEntireInventory() do\r\n        if inventoryItem and inventoryItem:GetMUID() == item:GetMUID() and inventoryItem:GetStackSize() then\r\n            stackSize = stackSize + inventoryItem:GetStackSize()\r\n        end\r\n    end\r\n    return stackSize\r\nend\r\n\r\n-- Returns the sum of all items in the inventory\r\nfunction Inventory:GetItemsSum()\r\n    local sum = 0\r\n    for i, inventoryItem in self:IterateEntireInventory() do\r\n        if inventoryItem then\r\n            sum = sum + inventoryItem:GetStackSize()\r\n        end\r\n    end\r\n    return sum\r\nend\r\n\r\n-- Returns a table of all the items along with their slot index and quantity\r\nfunction Inventory:GetAllItems()\r\n    local items = {}\r\n    for i, inventoryItem in self:IterateEntireInventory() do\r\n        if inventoryItem then\r\n            table.insert(items,{\r\n                slot = i,\r\n                item = inventoryItem,\r\n                quantity = inventoryItem:GetStackSize()\r\n            })\r\n        end\r\n    end\r\n    return items\r\nend\r\n\r\n------------------------------------------------------------------------------------------------\r\n-- Inventory Iterators\r\n------------------------------------------------------------------------------------------------\r\n-- These methods are used for iterating through specific parts of the inventory.\r\n--\r\n-- This is an example of iterating through the backpack slots.\r\n-- for slotIndex, item in self:IterateBackpackSlots() do end\r\n\r\n-- Get a table of equipped items\r\nfunction Inventory:IterateEquipSlots()\r\n    local function iter(_, slotIndex)\r\n        slotIndex = slotIndex + 1\r\n        if slotIndex <= #self.EQUIP_SLOTS then\r\n            return slotIndex, self:GetItem(slotIndex)\r\n        end\r\n    end\r\n    return iter, nil, 0 \r\nend\r\n\r\n-- Get a table of backpack items\r\nfunction Inventory:IterateBackpackSlots()\r\n    local startingSlot = #self.EQUIP_SLOTS\r\n    local function iter(_, slotIndex)\r\n        slotIndex = slotIndex == 0 and startingSlot or slotIndex\r\n        slotIndex = slotIndex + 1\r\n        if slotIndex <= self.BACKPACK_CAPACITY + startingSlot then\r\n            return slotIndex, self:GetItem(slotIndex)\r\n        end\r\n    end\r\n    return iter, nil, 0 \r\nend\r\n\r\n-- Get a table of all items\r\nfunction Inventory:IterateEntireInventory()\r\n    local function iter(_, slotIndex)\r\n        slotIndex = slotIndex + 1\r\n        if slotIndex <= self.TOTAL_CAPACITY then\r\n            return slotIndex, self:GetItem(slotIndex)\r\n        end\r\n    end\r\n    return iter, nil, 0 \r\nend\r\n------------------------------------------------------------------------------------------------\r\n\r\n-- Converts the 1-based backpack index into the correct inventory slot index.\r\nfunction Inventory:ConvertBackpackSlotIndex(backpackIndex)\r\n    assert(1 <= backpackIndex and backpackIndex <= self.BACKPACK_CAPACITY)\r\n    return #self.EQUIP_SLOTS + backpackIndex\r\nend\r\n\r\n-- Converts the slot type (and optional offset) into the correct inventory slot index.\r\nfunction Inventory:ConvertEquipSlotIndex(slotType, slotNumber)\r\n    slotNumber = slotNumber or 1\r\n    local number = 0\r\n    for i,equipSlot in ipairs(self.EQUIP_SLOTS) do\r\n        if equipSlot.slotType == slotType then\r\n            number = number + 1\r\n            if number == slotNumber then return i end\r\n        end\r\n    end\r\nend\r\n\r\n-- True if the slot represents a backpack item.\r\nfunction Inventory:IsBackpackSlot(slotIndex)\r\n    return slotIndex and #self.EQUIP_SLOTS < slotIndex and slotIndex <= self.TOTAL_CAPACITY\r\nend\r\n\r\n-- True if the slot represents an equipped item.\r\nfunction Inventory:IsEquipSlot(slotIndex)\r\n    return slotIndex and 1 <= slotIndex and slotIndex <= #self.EQUIP_SLOTS\r\nend\r\n\r\n-- True if the slot accepts the given type.\r\nfunction Inventory:IsEquipSlotType(slotIndex, slotType)\r\n    return self:IsEquipSlot(slotIndex) and self.EQUIP_SLOTS[slotIndex].slotType == slotType\r\nend\r\n\r\n-- True if the slot is empty.\r\nfunction Inventory:IsEmptySlot(slotIndex)\r\n    return self.slotItems[slotIndex] == nil\r\nend\r\n\r\n-- True if the slot is the primary weapon slot.\r\nfunction Inventory:IsMainHandSlot(slotIndex)\r\n    return slotIndex == 1\r\nend\r\n\r\n-- True if the slot is the offhand weapons slot.\r\nfunction Inventory:IsOffHandSlot(slotIndex)\r\n    return slotIndex == 2\r\nend \r\n\r\n-- True if the slot is a trinket slot.\r\nfunction Inventory:IsTrinketSlot(slotIndex)\r\n    return slotIndex >= 6 and slotIndex <= 8\r\nend \r\n\r\n-- True if the offhand slot is disabled.\r\nfunction Inventory:IsSlotEnabled(slotIndex)\r\n    if self:IsOffHandSlot(slotIndex) then\r\n        return not self.isOffHandDisabled\r\n    else\r\n        return true\r\n    end\r\nend\r\n\r\n-- True if the slot is the primary weapon slot.\r\nfunction Inventory:IsPrimaryWeaponSlot(slotIndex)\r\n    return slotIndex == 1\r\nend\r\n\r\n-- True if the backpack is full.\r\nfunction Inventory:IsBackpackFull()\r\n    return self:GetFreeBackpackSlot() == nil\r\nend\r\n\r\n-- Get the item at the given slot index.\r\nfunction Inventory:GetItem(slotIndex)  -- int slotIndex\r\n    return self.slotItems[slotIndex]\r\nend\r\n\r\n-- Returns true if the player has accessory slots that have no items in them.\r\nfunction Inventory:HasAvaliableAccessorySlots()\r\n    for _, item in self:IterateEquipSlots() do\r\n        if item and item:GetEquipSlotType() == \"Accessory\"  then\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\n-- Gets the weakest accessory from the equipped slots.\r\nfunction Inventory:GetWeakestAccessory()\r\n    local weakestAccessory = nil\r\n    local weakestAcessorySlot = nil\r\n    for slot, item in self:IterateEquipSlots() do\r\n        if item and item:GetEquipSlotType() == \"Accessory\" then\r\n            if not weakestAccessory then \r\n                weakestAccessory = item\r\n                weakestAcessorySlot = slot\r\n            end\r\n            local weakScore = 0\r\n            local stats = item:GetStatsBase()\r\n            for _, statName in pairs(stats) do\r\n                if Item.StatGreaterThan(weakestAccessory,item,statName.name) then\r\n                    weakScore = weakScore + 1\r\n                else\r\n                    weakScore = weakScore - 1\r\n                end\r\n            end\r\n            -- It\'s considered weak if half the stats are better.\r\n            if weakScore >= math.floor(#stats/2)+1 then\r\n                weakestAccessory = item\r\n                weakestAcessorySlot = slot\r\n            end\r\n        else\r\n            if self:IsEquipSlotType(slot,\"Accessory\") then\r\n                return nil, slot\r\n            end\r\n        end\r\n    end\r\n    return weakestAccessory, weakestAcessorySlot\r\nend\r\n\r\n-- Gets the first free backpack slot and returns the slot index.\r\nfunction Inventory:GetFreeBackpackSlot()\r\n    for slotIndex = #self.EQUIP_SLOTS+1,self.TOTAL_CAPACITY do\r\n        if self:IsBackpackSlot(slotIndex) and self:IsEmptySlot(slotIndex) then\r\n            return slotIndex\r\n        end\r\n    end\r\nend\r\n\r\n-- Gets the first free matching equip slot and returns the slot index.\r\nfunction Inventory:GetFreeEquipSlot(slotType) -- string slotType\r\n    for slotIndex = 1,#self.EQUIP_SLOTS do\r\n        if self:IsEquipSlotType(slotIndex, slotType) and self:IsEmptySlot(slotIndex) then\r\n            return slotIndex\r\n        end\r\n    end\r\nend\r\n\r\n-- Get the cumulative stat totals from all equipped items.\r\nfunction Inventory:GetStatTotals()\r\n    return self.statTotals\r\nend\r\n\r\n-- Get the stat deltas if the given item is equipped instead of the currently equipped item (in corresponding slot).\r\nfunction Inventory:GetStatDeltas(compareItem) -- Item compareItem\r\n    local slotIndex = self:ConvertEquipSlotIndex(compareItem:GetEquipSlotType())\r\n    local currentItem = self:GetItem(slotIndex)\r\n    local statDeltas = {}\r\n    for statName,_ in pairs(self.statTotals) do\r\n        statDeltas[statName] = compareItem:GetStatTotal(statName)\r\n        if currentItem then\r\n            statDeltas[statName] = statDeltas[statName] - currentItem:GetStatTotal(statName)\r\n        end\r\n    end\r\n    return statDeltas\r\nend\r\n\r\n-- True if the move operation is valid.\r\nfunction Inventory:CanMoveItem(fromSlotIndex, toSlotIndex)\r\n    return self:_CanMoveItemOneWay(fromSlotIndex, toSlotIndex) and self:_CanMoveItemOneWay(toSlotIndex, fromSlotIndex)\r\nend\r\n\r\n-- Move an item. If there is an item in the destination slot the items will swap. Acts as delete if destination slot is zero.\r\n-- If the destination is nil then it will drop the item.\r\nfunction Inventory:MoveItem(fromSlotIndex, toSlotIndex) -- int fromSlotIndex, int toSlotIndex\r\n    -- If it\'s being thrown out of the inventory and we allowed item drops.\r\n    if self.DROP_ITEM_INSTEAD_OF_DELETE and toSlotIndex == nil then\r\n        if self.owner and (self.owner:IsA(\"Player\")) then if(self.owner.isDead) then return end end\r\n        self:_FireEvent(\"itemDropEvent\", fromSlotIndex, toSlotIndex)\r\n        self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\n        self:_SetSlotItem(fromSlotIndex, nil)\r\n        return\r\n    elseif not self.DROP_ITEM_INSTEAD_OF_DELETE and toSlotIndex == nil then\r\n        self:_SetSlotItem(fromSlotIndex, nil)\r\n    -- If zero is provided then the item is not dropped and it will instead be deleted.\r\n    elseif toSlotIndex == 0 then\r\n        self:_SetSlotItem(fromSlotIndex, nil)\r\n    end\r\n    if not self:CanMoveItem(fromSlotIndex, toSlotIndex) then return end\r\n\r\n    -- Item stack fill when dropping on a matching item\r\n    local hasStacked = self:_StackSlotOntoSlot(fromSlotIndex,toSlotIndex)\r\n\r\n    -- Item swapping\r\n    local swapItem = nil\r\n    if toSlotIndex and not hasStacked then\r\n        swapItem = self.slotItems[toSlotIndex]\r\n        self:_SetSlotItem(toSlotIndex, self.slotItems[fromSlotIndex])\r\n    end\r\n\r\n    if not hasStacked then\r\n        self:_SetSlotItem(fromSlotIndex, swapItem)\r\n    end\r\n\r\n    \r\n    self:_FireEvent(\"itemMovedEvent\", fromSlotIndex, toSlotIndex)\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Registers a loot item with the inventory. This will display the loot item in the loot window.\r\nfunction Inventory:RegisterLootItem(lootInfo, onLootClaimed) -- string itemHash, function onLootClaimed\r\n    local lootID, lootHash = lootInfo:match(\"^(.*)@(.*)$\")\r\n    if self.lootInfos[lootID] then return end -- If already registered don\'t reregister.\r\n    local lootInfo = {\r\n        isClaimed = false,\r\n        id = lootID,\r\n        hash = lootHash,\r\n        item = self.database:CreateItemFromHash(lootHash),\r\n        onLootClaimed = onLootClaimed, -- Callback\r\n    }\r\n    self.lootInfos[lootID] = lootInfo\r\nend\r\n\r\n-- Unregister the loot item with the inventory. This will remove it from the loot window.\r\nfunction Inventory:UnRegisterLootItem(lootID) -- CoreObject lootWorldObject\r\n    self.lootInfos[lootID] = nil\r\nend\r\n\r\n-- True if the claim operation is valid.\r\nfunction Inventory:CanClaimLoot(lootID) -- int lootID\r\n    local lootInfo = self.lootInfos[lootID]\r\n    if lootInfo and not lootInfo.isClaimed then\r\n        if lootInfo.item:IsStackable() then\r\n            return self:_CanAccommodateStackableItem(lootInfo.item)\r\n        else\r\n            return self:GetFreeBackpackSlot() ~= nil\r\n        end\r\n    end\r\nend\r\n\r\n-- True if the claim operation is valid.\r\nfunction Inventory:CanClaimLootIgnoreOverflow(lootID) -- int lootID\r\n    local lootInfo = self.lootInfos[lootID]\r\n    if lootInfo and not lootInfo.isClaimed then\r\n        if lootInfo.item:IsStackable() then\r\n            return self:_CanAccommodateStackableIgnoringOverflow(lootInfo.item) > 0\r\n        else\r\n            return self:GetFreeBackpackSlot() ~= nil\r\n        end\r\n    end\r\nend\r\n\r\n-- Transfer a loot item into inventory and mark as claimed.\r\nfunction Inventory:ClaimLoot(lootID) -- int lootID\r\n    local lootInfo = self.lootInfos[lootID]\r\n    if lootInfo and not lootInfo.isClaimed then\r\n        lootInfo.isClaimed = true\r\n        if lootInfo.item:IsStackable() then\r\n            self:_AddItemToBackpack(lootInfo.item)\r\n        elseif lootInfo.item:IsBackpack() then\r\n            lootInfo.item:ClearStats()\r\n            lootInfo.item:NewBackpackInventory(Inventory,self.database,self.owner,lootInfo.hash)\r\n            self:_AddItemToBackpack(lootInfo.item)\r\n        else\r\n            local slotIndex = self:GetFreeBackpackSlot()\r\n            self:_SetSlotItem(slotIndex, lootInfo.item)\r\n        end\r\n        self:_FireEvent(\"lootClaimedEvent\", lootInfo.id)\r\n        self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\n        if lootInfo.onLootClaimed then lootInfo.onLootClaimed() end\r\n    end\r\nend\r\n\r\n-- Get a specific loot item.\r\nfunction Inventory:GetLootItem(lootID) -- int lootID\r\n    return self.lootInfos[lootID] and self.lootInfos[lootID].item or nil\r\nend\r\n\r\n-- Get information for all loots registered to this inventory.\r\nfunction Inventory:GetLootInfos()\r\n    return self.lootInfos\r\nend\r\n\r\n-- Salvages an item from a slot.\r\nfunction Inventory:SalvageItem(slotIndex) -- int slotIndex\r\n    local item = self:GetItem(slotIndex)\r\n    if not item then return end\r\n    self:_FireEvent(\"itemSalvage\",slotIndex)\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\n    if item:IsStackable() then\r\n        local newItem = Inventory:_Copy(item)\r\n        newItem:SetStackSize(1)\r\n        self:_RemoveItemFromBackpack(newItem)\r\n    else\r\n        self:_SetSlotItem(slotIndex,nil)\r\n    end\r\n\r\n    local components = item:GetSalvageComponents()\r\n    for _, component in pairs(components) do\r\n        local item = self.database:GetItemFromMUID(component.item)\r\n        if item:IsStackable() then\r\n            item:SetStackSize(component.amount)\r\n        end\r\n        self:_AddItemToBackpack(item)\r\n    end\r\nend\r\n\r\nfunction Inventory:CanAccommodateItem(item)\r\n    return self:_CanAccommodateItem(item)\r\nend\r\n\r\n-- Checks if the item in a given slot can be salvaged.\r\nfunction Inventory:CanAddSalvageProducts(slotIndex) -- int slotIndex\r\n    -- Check to see if we can stack with an existing item and if not then insert it into an empty space\r\n    local components = self:GetItem(slotIndex):GetSalvageComponents()\r\n    local willTakeItemSlot = true\r\n    local freeSlots = {}\r\n    local takenSlots = {}\r\n\r\n    -- Mark all slots as free initally\r\n    for backpackSlotIndex, _ in self:IterateBackpackSlots() do\r\n        table.insert(freeSlots,backpackSlotIndex)\r\n    end\r\n\r\n    for _, component in pairs(components) do\r\n        local componentItem = self.database:GetItemFromMUID(component.item)\r\n        local canAdd = false\r\n        -- If the component is stackable then check to see if it can be added to an existing stack.\r\n        if componentItem:IsStackable() then\r\n            componentItem:SetStackSize(component.amount)\r\n            local allowAdd, hasReplacedSalvagedItem, filledSlotIndexs = self:_CanAccommodateStackableItemAfterSalvage(componentItem, slotIndex, willTakeItemSlot, takenSlots)\r\n            canAdd = allowAdd\r\n            \r\n            -- Remove any taken slots.\r\n            if filledSlotIndexs then\r\n                for i, freeSlotIndex in ipairs(freeSlots) do\r\n                    for _, takenSlotIndex in pairs(filledSlotIndexs) do\r\n                        if freeSlotIndex == takenSlotIndex then\r\n                            freeSlots[i] = nil\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n\r\n            if canAdd then\r\n                canAdd = true\r\n                -- if our stackable item has taken the salvaged item slot then don\'t allow anything else to replace it.\r\n                if hasReplacedSalvagedItem then\r\n                    willTakeItemSlot = false\r\n                end\r\n            end\r\n        end\r\n        if not componentItem:IsStackable() and not canAdd then\r\n            -- Check for empty spot since the item is not stackable.\r\n            for i, backpackIndex in pairs(freeSlots) do\r\n                local slotItem = self:GetItem(backpackIndex)\r\n                -- If the item we\'re salvaging is the slot index then mark it as we\'re replacing it.\r\n                if backpackIndex == slotIndex and willTakeItemSlot then\r\n                    freeSlots[i] = nil\r\n                    canAdd = true\r\n                    willTakeItemSlot = false\r\n                    break\r\n                -- If there is an open slot\r\n                elseif not slotItem then \r\n                    freeSlots[i] = nil\r\n                    canAdd = true\r\n                    break\r\n                end\r\n            end\r\n        end\r\n        if not canAdd then\r\n            -- If a single component can not be added then return false.\r\n            return false\r\n        end\r\n    end\r\n    -- If all components can be added then return true.\r\n    return true\r\nend\r\n\r\n-- Consume one item at the specified index.\r\nfunction Inventory:ConsumeItem(slotIndex) -- int slotIndex\r\n    local item = self:GetItem(slotIndex)\r\n    if item and item:GetType() == \"Consumable\" then\r\n        item:ApplyConsumptionEffect(self.owner)\r\n        local itemAfterConsumption = nil\r\n        if item:IsStackable() and item:GetStackSize() > 1 then\r\n            item:SetStackSize(item:GetStackSize() - 1)\r\n            itemAfterConsumption = item\r\n        end\r\n        self:_SetSlotItem(slotIndex, itemAfterConsumption)\r\n        self:_FireEvent(\"itemConsumedEvent\", slotIndex)\r\n        self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\n    end\r\nend\r\n\r\n-- Opens a backpack at a slot index\r\nfunction Inventory:OpenBackpack(slotIndex)\r\n    local item = self:GetItem(slotIndex)\r\n    if item:IsBackpack() then\r\n        Events.Broadcast(\"BackpackOpen\",item:GetBackpackInventory(),slotIndex)\r\n    end\r\nend\r\n\r\n-- Hash suitable for runtime use. Indexes are preferred over full MUIDs for compactness.\r\nfunction Inventory:RuntimeHash()\r\n    return self:_IntoHash(true)\r\nend\r\n\r\n-- Hash suitable for persistance. MUIDs are preferred over indexes for future-proofing.\r\nfunction Inventory:PersistentHash()\r\n    return self:_IntoHash(false)\r\nend\r\n\r\n-- Update an equipment slot from hash value. Used by replicated clients.\r\nfunction Inventory:UpdateEquipSlotFromHash(slotIndex, itemHash) -- int slotIndex, string itemHash\r\n    assert(self:IsEquipSlot(slotIndex))\r\n    local item = nil\r\n    if #itemHash > 0 then\r\n        item = self.database:CreateItemFromHash(itemHash)\r\n    end\r\n    self:_SetSlotItem(slotIndex, item)\r\n    self:_FireEvent(\"OnInventoryChanged\",self.owner)\r\nend\r\n\r\n-- Sets the lock of the players abilities\r\nfunction Inventory:UpdateLockAbilities(isLocked) -- bool isLocked\r\n    self:_FireEvent(\"SetLockAbilities\",isLocked)\r\nend\r\n\r\n\r\n-- -- Executes a primary item craft, removing the ingredients from the inventory and modifying the primary item in place.\r\n-- function Inventory:ExecutePrimaryItemCraft(recipeItem, primaryItemSlotIndex)\r\n--     local ingredientRequiredAmounts = {}\r\n--     local craftingData = recipeItem:GetCraftingRecipeData()\r\n--     for _,ingredient in ipairs(craftingData.ingredients) do\r\n--         if ingredient.item then\r\n--             ingredientRequiredAmounts[ingredient.item:GetIndex()] = ingredient.amount or 1\r\n--         end\r\n--     end\r\n--     -- Subtract the ingredients. While it would be nice to take from the smallest stack first, it is far easier to just\r\n--     -- remove in the order we encounter them in the inventory.\r\n--     for i=1,self.TOTAL_CAPACITY do\r\n--         local item = self:GetItem(i)\r\n--         if item then\r\n--             local index = item:GetIndex()\r\n--             local requiredAmount = ingredientRequiredAmounts[index]\r\n--             if requiredAmount and requiredAmount > 0 then\r\n--                 if item:IsStackable() then\r\n--                     local amountToRemove = math.min(requiredAmount, item:GetStackSize())\r\n--                     if amountToRemove == item:GetStackSize() then\r\n--                         self:_SetSlotItem(i, nil)\r\n--                     else\r\n--                         item:SetStackSize(item:GetStackSize() - amountToRemove)\r\n--                     end\r\n--                     ingredientRequiredAmounts[index] = requiredAmount - amountToRemove\r\n--                 else\r\n--                     self:_SetSlotItem(i, nil)\r\n--                     ingredientRequiredAmounts[index] = requiredAmount - 1\r\n--                 end\r\n--             end\r\n--         end\r\n--     end\r\n--     -- Perform the modification.\r\n--     local primaryItem = self:GetItem(primaryItemSlotIndex)\r\n--     craftingData.method:Execute(recipeItem, primaryItem)\r\n--     -- Fire event so that this operation is replicated.\r\n--     self:_FireEvent(\"craftExecutedEvent\", recipeItem, primaryItemSlotIndex)\r\n-- end\r\n\r\n-- Count up the number of available ingredients.\r\nfunction Inventory:CountStackableTotal(stackableItem)\r\n    if not (stackableItem and stackableItem:IsStackable()) then return end\r\n    local count = 0\r\n    for i=1,self.TOTAL_CAPACITY do\r\n        local item = self:GetItem(i)\r\n        if item and item:WillStackWith(stackableItem) then\r\n            count = count + item:GetStackSize()\r\n        end\r\n    end\r\n    return count\r\nend\r\n\r\n-- Determine if we can foot the bill for this upgrade.\r\nfunction Inventory:CanExecuteItemUpgrade(slotIndex)\r\n    local itemToUpgrade = self:GetItem(slotIndex)\r\n    if itemToUpgrade and itemToUpgrade:CanUpgrade() then\r\n        local itemToSpend, costRemaining = UpgradesCostBasis.AppraiseItemUpgrade(itemToUpgrade)\r\n        for i=1,self.TOTAL_CAPACITY do\r\n            local item = self:GetItem(i)\r\n            if item and item:WillStackWith(itemToSpend) then\r\n                costRemaining = costRemaining - item:GetStackSize()\r\n                if costRemaining <= 0 then return true end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-- Expend the required amount of resources and upgrade the item.\r\nfunction Inventory:ExecuteItemUpgrade(slotIndex)\r\n    local itemToUpgrade = slotIndex and self:GetItem(slotIndex) or nil\r\n    if itemToUpgrade and itemToUpgrade:CanUpgrade() then\r\n        local itemToSpend, costRemaining = UpgradesCostBasis.AppraiseItemUpgrade(itemToUpgrade)\r\n        local slotsWithSpendableStack = {}\r\n        for i=1,self.TOTAL_CAPACITY do\r\n            local item = self:GetItem(i)\r\n            if item and item:WillStackWith(itemToSpend) then\r\n                table.insert(slotsWithSpendableStack, i)\r\n            end\r\n        end\r\n        -- Sort them by increasing stack size so that we spend through smaller stacks first.\r\n        table.sort(slotsWithSpendableStack, function(a, b)\r\n            local itemA = self:GetItem(a)\r\n            local itemB = self:GetItem(b)\r\n            return itemA:GetStackSize() < itemB:GetStackSize()\r\n        end)\r\n        -- Spend down the full cost.\r\n        for _,spendableSlotIndex in ipairs(slotsWithSpendableStack) do\r\n            local item = self:GetItem(spendableSlotIndex)\r\n            local amountToSpend = math.min(costRemaining, item:GetStackSize())\r\n            local newStackSize = item:GetStackSize() - amountToSpend\r\n            if newStackSize == 0 then\r\n                self:_SetSlotItem(spendableSlotIndex, nil)\r\n            else\r\n                item:SetStackSize(newStackSize)\r\n            end\r\n            costRemaining = costRemaining - amountToSpend\r\n            if costRemaining == 0 then break end\r\n        end\r\n        if costRemaining ~= 0 then\r\n            warn(\"Something went wrong when executing item upgrade!\")\r\n        else\r\n            itemToUpgrade:Upgrade()\r\n        end\r\n        self:_UpdateStatTotals()\r\n        self:_FireEvent(\"itemUpgradedEvent\", slotIndex)\r\n    end\r\nend\r\n\r\n-- Connect this inventory instance to a stat sheet instance. Any changes to the inventory will reflect themselves\r\n-- in the statsheet.\r\nfunction Inventory:ConnectToStatSheet(statSheet)\r\n    assert(not self.connectedStatSheet, \"inventory already has connected stat sheet\")\r\n    -- Set up the static modifiers on the stat sheet.\r\n    local doNotReplicate = true\r\n    self.connectedStatSheet = statSheet\r\n    self.connectedStatSheetModifiers = {\r\n        Health          = statSheet:NewStatModifierAdd(\"Health\",       0, doNotReplicate),\r\n        HealthPercent   = statSheet:NewStatModifierMul(\"Health\",       1, doNotReplicate),\r\n        Defense         = statSheet:NewStatModifierAdd(\"Defense\",      0, doNotReplicate),\r\n        Attack          = statSheet:NewStatModifierAdd(\"Attack\",       0, doNotReplicate),\r\n        Magic           = statSheet:NewStatModifierAdd(\"Magic\",        0, doNotReplicate),\r\n        CritChance      = statSheet:NewStatModifierAdd(\"CritChance\",   0, doNotReplicate),\r\n        CDR             = statSheet:NewStatModifierAdd(\"CDR\",          0, doNotReplicate),\r\n        Haste           = statSheet:NewStatModifierAdd(\"Haste\",        0, doNotReplicate),\r\n        Tenacity        = statSheet:NewStatModifierAdd(\"Tenacity\",     0, doNotReplicate),\r\n    }\r\n    self:_UpdateConnectedStatSheet()\r\nend\r\n\r\n-- Returns the result of an \"equip-item-quick-compare\". Namely, how will the stats change if I equip this item?\r\nfunction Inventory:GetQuickCompareStatDeltas(equipSlotIndex, itemToTest)\r\n    local itemAlreadyEquipped = self:GetItem(equipSlotIndex)\r\n    local doNotFireEvent = true\r\n    local statDeltas = {}\r\n    for _,statName in ipairs(self.connectedStatSheet.STATS) do statDeltas[statName] = -self.connectedStatSheet:GetStatTotalValue(statName) end\r\n    self:_SetSlotItem(equipSlotIndex, itemToTest, doNotFireEvent)\r\n    for _,statName in ipairs(self.connectedStatSheet.STATS) do statDeltas[statName] = statDeltas[statName] + self.connectedStatSheet:GetStatTotalValue(statName) end\r\n    self:_SetSlotItem(equipSlotIndex, itemAlreadyEquipped, doNotFireEvent)\r\n    return statDeltas\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PRIVATE\r\n---------------------------------------------------------------------------------------------------------\r\nfunction Inventory:_Init(database, owner)\r\n    self.hasLoaded = false\r\n    self.database = database\r\n    self.owner = owner\r\n    self.lootInfos = {}\r\n    self:_ClearSlots()\r\n    self:_UpdateSlotStatus()\r\n    self:_UpdateStatTotals()\r\nend\r\n\r\nfunction Inventory:_ClearSlots()\r\n    self.slotItems = {}\r\n    self.equippedItems = {}\r\n    self.isOffhandDisabled = false\r\nend\r\n\r\nfunction Inventory:_IntoHash(isRuntime)\r\n    local hashParts = {}\r\n    table.insert(hashParts, isRuntime and \"R\" or \"P\")\r\n    for slotIndex = 1,self.TOTAL_CAPACITY do\r\n        local item = self:GetItem(slotIndex)\r\n        if item then\r\n            local slotId = Base64.Encode6(slotIndex)\r\n            if not isRuntime then\r\n                if self:IsEquipSlot(slotIndex) then\r\n                    slotId = \"E\" .. self.EQUIP_SLOTS[slotIndex].slotType\r\n                else\r\n                    slotId = \"B\" .. Base64.Encode6(slotIndex - #self.EQUIP_SLOTS)\r\n                end\r\n            end\r\n            table.insert(hashParts, string.format(\"<%s>\", slotId))\r\n            table.insert(hashParts, item:_IntoHash(isRuntime))\r\n            table.insert(hashParts, \";\")\r\n        end\r\n    end\r\n    return table.concat(hashParts)\r\nend\r\n\r\nlocal SLOT_PATTERN = \"<([^<>;]+)>([^<>;]+)<([^<>;]+)>;\"\r\nfunction Inventory:_LoadHash(hash)\r\n    local hashType = hash:sub(1,1)\r\n    local hashData = hash:sub(2)\r\n    local isRuntime = hashType == \"R\"\r\n    local currentBackpack = self\r\n    local currentCount = 0\r\n    for slotId,itemHash,subItemCount in hashData:gmatch(SLOT_PATTERN) do\r\n        if currentCount > 0 then -- Populate current backpack and not the inventory\r\n            currentCount = currentCount - 1\r\n        else\r\n            currentBackpack = self\r\n        end\r\n\r\n        local slotIndex = nil\r\n        if isRuntime then\r\n            slotIndex = Base64.Decode6(slotId)\r\n        elseif slotId:sub(1,1) == \"B\" then\r\n            slotIndex = #currentBackpack.EQUIP_SLOTS + Base64.Decode6(slotId:sub(2))\r\n        elseif slotId:sub(1,1) == \"E\" then\r\n            slotIndex = currentBackpack:GetFreeEquipSlot(slotId:sub(2))\r\n        end\r\n\r\n        local newItem = Item.FromHash(self.database, itemHash)\r\n        local copyItem = nil\r\n        if not newItem then\r\n            warn(\"The inventory has failed to load an item. This item may not exist in the item registry. The item has been deleted from the inventory.\")\r\n            currentBackpack:_SetSlotItem(slotIndex, nil)\r\n        elseif currentBackpack then\r\n            copyItem = self:_Copy(newItem)\r\n            currentBackpack:_SetSlotItem(slotIndex, copyItem)\r\n        elseif currentBackpack == nil then\r\n            currentBackpack = self\r\n        end\r\n\r\n\r\n        if newItem and copyItem and copyItem:IsBackpack() then -- Constructs an inventory for the backpack\r\n            copyItem:ClearStats() -- Backpacks can not have stats.\r\n            copyItem:NewBackpackInventory(Inventory,self.database,self.owner,itemHash)\r\n            currentBackpack = copyItem:GetBackpackInventory()\r\n            currentCount = tonumber(subItemCount) \r\n        end\r\n    end\r\nend\r\n\r\nfunction Inventory:_FireEvent(eventName, ...)\r\n    for _,handler in ipairs(self.eventHandlers[eventName]) do\r\n        handler(...)\r\n    end\r\nend\r\n\r\nfunction Inventory:_DefineEvent(eventName)\r\n    self.eventHandlers = self.eventHandlers or {}\r\n    self.eventHandlers[eventName] = self.eventHandlers[eventName] or {}\r\n    self[eventName] = {\r\n        Connect = function(_, handler)\r\n            table.insert(self.eventHandlers[eventName], handler)\r\n            return self[eventName]\r\n        end,\r\n        Disconnect = function(_, handler)\r\n            table.remove(self.eventHandlers[eventName], handler)\r\n        end\r\n    }\r\nend\r\n\r\nfunction Inventory:_CanMoveItemOneWay(fromSlotIndex, toSlotIndex)\r\n    if not toSlotIndex then\r\n        return true\r\n    end\r\n    local item = self:GetItem(fromSlotIndex)\r\n    if not item then\r\n        return true\r\n    end\r\n    if self:IsBackpackSlot(toSlotIndex) then\r\n        return true\r\n    end\r\n    if self:IsEquipSlotType(toSlotIndex, item:GetEquipSlotType()) then\r\n        return true\r\n    end\r\nend\r\n\r\nfunction Inventory:_CanAccommodateItem(item)\r\n   if self:GetFreeBackpackSlot() or\r\n        self:_CanAccommodateStackableItem(item) then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\nfunction Inventory:_StackSlotOntoSlot(fromSlotIndex, toSlotIndex)\r\n    local fromItem, toItem = self:GetItem(fromSlotIndex), self:GetItem(toSlotIndex)\r\n    if fromItem and toItem then\r\n        if toItem:WillStackWith(fromItem) and not toItem:IsFullStack() and not fromItem:IsFullStack() then\r\n            local amountToAdd = math.min(fromItem:GetStackSize(), toItem:GetAvailableStackSpace())\r\n            toItem:SetStackSize(toItem:GetStackSize() + amountToAdd)\r\n            local newStackSize = fromItem:GetStackSize() - amountToAdd\r\n            if newStackSize > 0 then\r\n                fromItem:SetStackSize(newStackSize)\r\n            else\r\n                self:_SetSlotItem(fromSlotIndex,nil)\r\n            end\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nfunction Inventory:_StackItemOntoSlot(item, toSlotIndex)\r\n    local toItem = self:GetItem(toSlotIndex)\r\n    if item and toItem then\r\n        if toItem:WillStackWith(item) and not toItem:IsFullStack() then\r\n            local amountToAdd = math.min(item:GetStackSize(), toItem:GetAvailableStackSpace())\r\n            toItem:SetStackSize(toItem:GetStackSize() + amountToAdd)\r\n            local newStackSize = item:GetStackSize() - amountToAdd\r\n            if newStackSize > 0 then\r\n                item:SetStackSize(newStackSize)\r\n            else\r\n                item:SetStackSize(0)\r\n            end\r\n            return item, toItem:GetStackSize()\r\n        end\r\n    end\r\n    return item, nil\r\nend\r\n\r\nfunction Inventory:_CanAccommodateAfterRemovalOfItems(tableOfItems)\r\n    local items = self:GetAllItems()\r\n    for _, index in pairs(tableOfItems) do\r\n        for _, itemSlot in pairs(items) do\r\n            if (itemSlot.item:GetName() == index.item:GetName()) then\r\n                if(index.quantity >= itemSlot.quantity) then return true else\r\n                    itemSlot.quantity = itemSlot.quantity - index.quantity\r\n                    index.quantity = 0\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n\r\nfunction Inventory:_CanAccommodateStackableItem(item)\r\n    if not item:IsStackable() then return end\r\n    local stackSpace = 0\r\n    for slotIndex, _ in self:IterateBackpackSlots() do\r\n        assert(self:IsBackpackSlot(slotIndex))\r\n        if self:IsEmptySlot(slotIndex) then\r\n            stackSpace = stackSpace + item:GetMaxStackSize()\r\n        elseif item:WillStackWith(self:GetItem(slotIndex)) then\r\n            stackSpace = stackSpace + self:GetItem(slotIndex):GetAvailableStackSpace()\r\n        end\r\n        -- Check if we have enough and exit early.\r\n        if stackSpace >=  item:GetStackSize() then return true end\r\n    end\r\nend\r\n\r\nfunction Inventory:_CanAccommodateStackableItemAfterSalvage(item, salvagedSlotIndex, willTakeSalvagedSlot, alreadyFilledSlotIndexs)\r\n    if not item:IsStackable() then return end\r\n    local stackSpace = 0\r\n    local hasReplacedSalvageSlot = false\r\n    local filledSlotIndexs = alreadyFilledSlotIndexs or {}\r\n    for slotIndex, _ in self:IterateBackpackSlots() do\r\n        assert(self:IsBackpackSlot(slotIndex))\r\n        local isOpen = true\r\n        -- Make sure the slot is not already waiting to be assigned.\r\n        for i, filledIndex in pairs(filledSlotIndexs) do\r\n            if filledIndex == slotIndex then\r\n                isOpen = false\r\n            end\r\n        end\r\n\r\n        -- If the slot is open and has not already been taken when provided the already filled slot indexs.\r\n        if isOpen then\r\n            if self:IsEmptySlot(slotIndex) or slotIndex == salvagedSlotIndex then\r\n                stackSpace = stackSpace + item:GetMaxStackSize()\r\n                if slotIndex == salvagedSlotIndex and willTakeSalvagedSlot then\r\n                    hasReplacedSalvageSlot = true\r\n                end\r\n                table.insert(filledSlotIndexs,slotIndex)\r\n            elseif item:WillStackWith(self:GetItem(slotIndex)) then\r\n                stackSpace = stackSpace + self:GetItem(slotIndex):GetAvailableStackSpace()\r\n            end\r\n        end\r\n\r\n        -- Check if we have enough and exit early.\r\n        if stackSpace >=  item:GetStackSize() then return true, hasReplacedSalvageSlot, filledSlotIndexs end\r\n    end\r\nend\r\n\r\n\r\nfunction Inventory:_CanAccommodateStackableIgnoringOverflow(item)\r\n    if not item:IsStackable() then return end\r\n    local stackSpace = 0\r\n    for slotIndex, _ in self:IterateBackpackSlots() do\r\n        assert(self:IsBackpackSlot(slotIndex))\r\n        if self:IsEmptySlot(slotIndex) then\r\n            stackSpace = stackSpace + item:GetMaxStackSize()\r\n        elseif item:WillStackWith(self:GetItem(slotIndex)) then\r\n            stackSpace = stackSpace + self:GetItem(slotIndex):GetAvailableStackSpace()\r\n        end\r\n    end\r\n    -- Return Overflow Amount\r\n    return stackSpace\r\nend\r\n\r\nfunction Inventory:_AddItemToBackpack(itemToAdd)\r\n    -- First add to existing stacks where possible.\r\n    for slotIndex, itemInSlot in self:IterateBackpackSlots() do\r\n        if itemInSlot and itemToAdd:WillStackWith(itemInSlot) and not itemInSlot:IsFullStack() then\r\n            local amountToAdd = math.min(itemToAdd:GetStackSize(), itemInSlot:GetAvailableStackSpace())\r\n            itemInSlot:SetStackSize(itemInSlot:GetStackSize() + amountToAdd)\r\n            local newStackSize = itemToAdd:GetStackSize() - amountToAdd\r\n            if newStackSize > 0 then\r\n                itemToAdd:SetStackSize(newStackSize)\r\n            else\r\n                return\r\n            end\r\n        end\r\n    end\r\n    -- Second add the item to an empty slot if there is nothing to stack into\r\n    if itemToAdd:IsStackable() then\r\n        for slotIndex, itemInSlot in self:IterateBackpackSlots() do\r\n            if not itemInSlot then\r\n                local copyItem = self:_Copy(itemToAdd)\r\n                local amountToAdd = math.min(itemToAdd:GetStackSize(), itemToAdd:GetMaxStackSize())\r\n                itemToAdd:SetStackSize(itemToAdd:GetStackSize() - amountToAdd)\r\n                copyItem:SetStackSize(amountToAdd)\r\n                self:_SetSlotItem(slotIndex, copyItem)\r\n                if itemToAdd:GetStackSize() == 0 then\r\n                    return\r\n                end\r\n            end\r\n        end\r\n    else\r\n        for slotIndex, item in self:IterateBackpackSlots() do\r\n            if not item then\r\n                self:_SetSlotItem(slotIndex, itemToAdd)\r\n                return\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction Inventory:_RemoveItemFromBackpack(itemToRemove)\r\n    -- First remove from existing stacks where possible.\r\n    for slotIndex = #self.EQUIP_SLOTS+1,self.TOTAL_CAPACITY do\r\n        local itemInSlot = self:GetItem(slotIndex)\r\n        if itemInSlot and itemToRemove:GetMUID() == itemInSlot:GetMUID() then\r\n            local slotStackSize = itemInSlot:GetStackSize()\r\n            if slotStackSize <= itemToRemove:GetStackSize() then\r\n                itemToRemove:SetStackSize(itemToRemove:GetStackSize() - slotStackSize)\r\n                self:_SetSlotItem(slotIndex,nil)\r\n            else\r\n                itemInSlot:SetStackSize(slotStackSize - itemToRemove:GetStackSize())\r\n                return\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction Inventory:_UpdateStatTotals()\r\n    self.statTotals = self.statTotals or {}\r\n    for _,statName in ipairs(Item.STATS) do\r\n        self.statTotals[statName] = 0\r\n    end\r\n    for slotIndex = 1,#self.EQUIP_SLOTS do\r\n        local item = self:GetItem(slotIndex)\r\n        if item then\r\n            if item:GetEquipSlotType() == \"OffHand\" and self.isOffHandDisabled then\r\n                -- We have to be careful to not include offhand stats when they are disabled (by having a 2H weapon in mainhand).\r\n            else\r\n                -- Accumulate stat contribution.\r\n                for _,statName in ipairs(Item.STATS) do\r\n                    local itemStatAmount = item:GetStatTotal(statName)\r\n                    self.statTotals[statName] = self.statTotals[statName] + itemStatAmount\r\n                end\r\n            end\r\n        end\r\n    end\r\n    self:_UpdateConnectedStatSheet()\r\nend\r\n\r\nfunction Inventory:_UpdateConnectedStatSheet()\r\n    if not self.connectedStatSheet then return end\r\n    -- Read total item stats and apply to stat sheet.\r\n    local itemStatTotals = self:GetStatTotals()\r\n    self.connectedStatSheetModifiers.Health.addend             = itemStatTotals.Health\r\n    self.connectedStatSheetModifiers.HealthPercent.multiplier  = (itemStatTotals.HealthPercent / 100) + 1\r\n    self.connectedStatSheetModifiers.Defense.addend            = itemStatTotals.Defense\r\n    self.connectedStatSheetModifiers.Attack.addend             = itemStatTotals.Attack\r\n    self.connectedStatSheetModifiers.Magic.addend              = itemStatTotals.Magic\r\n    self.connectedStatSheetModifiers.CritChance.addend         = itemStatTotals.CritChance\r\n    self.connectedStatSheetModifiers.CDR.addend                = itemStatTotals.CDR\r\n    self.connectedStatSheetModifiers.Haste.addend              = itemStatTotals.Haste\r\n    self.connectedStatSheetModifiers.Tenacity.addend           = itemStatTotals.Tenacity\r\n    -- Tell the stat sheet to recalculate.\r\n    self.connectedStatSheet:Update()\r\nend\r\n\r\nfunction Inventory:_RecalculateStatTotals()\r\n    warn(\"Inventory:_RecalculateStatTotals() deprecated. Use Inventory:_UpdateStatTotals()\")\r\n    self.statTotals = self.statTotals or {}\r\n    for _,statName in ipairs(Item.STATS) do\r\n        self.statTotals[statName] = 0\r\n    end\r\n    for slotIndex = 1,#self.EQUIP_SLOTS do\r\n        local item = self:GetItem(slotIndex)\r\n        if item then\r\n            if not(self.EQUIP_SLOTS[slotIndex].slotType == \"OffHand\" and self.isOffHandDisabled) then\r\n                -- Accumulate stat contribution.\r\n                for _,statName in ipairs(Item.STATS) do\r\n                    local itemStatAmount = item:GetStatTotal(statName)\r\n                    self.statTotals[statName] = self.statTotals[statName] + itemStatAmount\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction Inventory:_Clear()\r\n    for i=1,self.BACKPACK_CAPACITY do\r\n        self.slotItems[i] = nil\r\n    end\r\nend\r\n\r\nfunction Inventory:_SetSlotItem(slotIndex, item)\r\n    -- Assumes validation has been done already.\r\n    local itemBeforeSet = self:GetItem(slotIndex)\r\n    -- If the backpack item is removed then fire the event.\r\n    if itemBeforeSet and itemBeforeSet:IsBackpack() and not item then\r\n        self:_FireEvent(\"backpackRemoved\",slotIndex)\r\n    end\r\n\r\n    self.slotItems[slotIndex] = item\r\n    if self:IsEquipSlot(slotIndex) then\r\n        self.equippedItems[slotIndex] = item\r\n        self.isOffhandDisabled = false\r\n        if item then\r\n            local constraints = Item.SLOT_CONSTRAINTS[item:GetType()]\r\n            self.isOffhandDisabled = constraints.isOffhandDisabled or false\r\n        end\r\n        self:_UpdateSlotStatus()\r\n        self:_UpdateStatTotals()\r\n        self:_FireEvent(\"itemEquippedEvent\", slotIndex, item)\r\n    end\r\nend\r\n\r\nfunction Inventory:_UpdateSlotStatus()\r\n    self.isOffHandDisabled = false\r\n    local mainHandItem = self:GetItem(1)\r\n    if mainHandItem and mainHandItem:IsTwoHanded() then\r\n        self.isOffHandDisabled = true\r\n    end\r\nend\r\n\r\n\r\n\r\n-- Used for copying an item table by value.\r\n-- Credit: https://stackoverflow.com/questions/640642/how-do-you-copy-a-lua-table-by-value\r\nfunction Inventory:_Copy(obj, seen)\r\n    if type(obj) ~= \'table\' then return obj end\r\n    if seen and seen[obj] then return seen[obj] end\r\n    local s = seen or {}\r\n    local res = setmetatable({}, getmetatable(obj))\r\n    s[obj] = res\r\n    for k, v in pairs(obj) do res[self:_Copy(k, s)] = self:_Copy(v, s) end\r\n    return res\r\nend\r\n\r\nfunction Inventory:__tostring()\r\n    local parts = { \"Inventory:\\n\" }\r\n    for slotIndex = 1,self.TOTAL_CAPACITY do\r\n        local item = self.slotItems[slotIndex]\r\n        if self:IsEquipSlot(slotIndex) then\r\n            table.insert(parts, string.format(\"\\t%-10s = %s\\n\", self.EQUIP_SLOTS[slotIndex].slotType, item and item:GetName() or \"\"))\r\n        elseif not self:IsEmptySlot(slotIndex) then\r\n            table.insert(parts, string.format(\"\\tpack %02d    = %4dx %s\\n\",\r\n                slotIndex - #self.EQUIP_SLOTS,\r\n                item and item:GetStackSize(),\r\n                item and item:GetName() or \"\"))\r\n        end\r\n    end\r\n    return table.concat(parts)\r\nend\r\n\r\nreturn Inventory"
        CustomParameters {
          Overrides {
            Name: "cs:ItemSystems_Item"
            AssetReference {
              Id: 5903881589588767374
            }
          }
          Overrides {
            Name: "cs:Base64"
            AssetReference {
              Id: 3976507683543157652
            }
          }
          Overrides {
            Name: "cs:RuntimeContextDetection"
            AssetReference {
              Id: 10260961104607564468
            }
          }
          Overrides {
            Name: "cs:ItemSystems_UpgradesCostBasis"
            AssetReference {
              Id: 16535789070687168046
            }
          }
          Overrides {
            Name: "cs:DropItemInsteadOfDelete"
            Bool: true
          }
          Overrides {
            Name: "cs:DropItemInsteadOfDelete:tooltip"
            String: "When enabled players can drop items straight from their inventory onto the ground for the nearest players to loot. Disabling this will have the players trash their items instead of dropping them"
          }
        }
      }
    }
    Assets {
      Id: 16535789070687168046
      Name: "ItemSystems_UpgradesCostBasis"
      PlatformAssetType: 3
      TextAsset {
        Text: "local Database = require(script:GetCustomProperty(\"Database\"))\r\nDatabase:WaitUntilLoaded()\r\n\r\nlocal ENHANCEMENT_BASE_COST = 3\r\nlocal ENHANCEMENT_POWER_COST = 1.3\r\nlocal LIMIT_BREAK_BASE_COST = 1\r\n\r\nlocal mockItemEnhancement = nil\r\nlocal mockItemLimitBreak = nil\r\nlocal hasInitialized = nil\r\n\r\n-- local function LazyInit()\r\n--     if hasInitialized then return end\r\n--     hasInitialized = true\r\n--     \r\n--     assert(ENHANCEMENT_CURRENCY_MUID)\r\n--     assert(LIMIT_BREAK_CURRENCY_MUID)\r\n--     local enhancementItemData = Database:FindItemDataByMUID(ENHANCEMENT_CURRENCY_MUID)\r\n--     local limitBreakItemData = Database:FindItemDataByMUID(LIMIT_BREAK_CURRENCY_MUID)\r\n--     assert(enhancementItemData, \"Cannot find enhancement currency item.\")\r\n--     assert(limitBreakItemData, \"Cannot find limit break currency item.\")\r\n--     mockItemEnhancement = Database:CreateItemFromData(enhancementItemData)\r\n--     mockItemLimitBreak = Database:CreateItemFromData(limitBreakItemData)\r\n-- end\r\n\r\n--------------------------------------------------------------------------------------------------------------\r\nlocal UpgradesCostBasis = {}\r\n\r\n-- Returns the cost item MUID and the price.\r\nfunction UpgradesCostBasis.AppraiseItemUpgrade(item)\r\n    if not item then return end\r\n    if not item:GetName() then return end\r\n\r\n    -- USEFUL QUANTITIES FOR COMPUTING COST...\r\n    -- Enhancement can be anything from 0-50.\r\n    local enhancementNumber = item:GetEnhancementLevel()\r\n    -- Limit break can be anything from 1-5.\r\n    local limitBreakNumber = item:GetLimitBreakLevel()\r\n    -- Rarity can be 1-5 (common, uncommon, rare, epic, legendary).\r\n    local rarityNumber = item.RARITIES[item:GetRarity()]\r\n\r\n    if item:IsNextUpgradeEnhancement() then\r\n\r\n        local enhancementItemName = item:GetRequiredEnhancementItemName()\r\n        local mockItemEnhancement = Database:GetItemFromName(enhancementItemName)\r\n\r\n        -- Compute the cost to enhance an item by one.\r\n        local cost = math.floor((ENHANCEMENT_BASE_COST * rarityNumber) + (rarityNumber+enhancementNumber)^ENHANCEMENT_POWER_COST) \r\n\t\t\r\n\t\tif item:IsTwoHanded() then\r\n\t\t\tcost = cost*2\r\n\t\tend\r\n        -- Return example cost item and cost.\r\n        return mockItemEnhancement, math.floor(cost)\r\n\r\n    elseif item:IsNextUpgradeLimitBreak() then\r\n\r\n        local limitBreakItemName = item:GetRequiredLimitBreakingItemName()\r\n        local mockItemLimitBreak = Database:GetItemFromName(limitBreakItemName)\r\n\r\n        -- Compute the cost to limit break an item to the next star-level.\r\n        local cost = LIMIT_BREAK_BASE_COST * (rarityNumber-1 + limitBreakNumber)^2\r\n\t\t\r\n\t\tif item:IsTwoHanded() then\r\n\t\t\tcost = cost*2\r\n\t\tend\r\n\t\t\r\n        -- Return example cost item and cost.\r\n        return mockItemLimitBreak, math.floor(cost)\r\n\r\n    end\r\nend\r\n\r\nreturn UpgradesCostBasis"
        CustomParameters {
          Overrides {
            Name: "cs:Database"
            AssetReference {
              Id: 8583392859467906295
            }
          }
        }
      }
    }
    Assets {
      Id: 8583392859467906295
      Name: "ItemSystems_Database"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Database\r\n    ====================\r\n\r\n    Reads and indexes the raw data scripts. Provides factory methods for creating items.\r\n]]\r\n\r\nlocal Item = require(script:GetCustomProperty(\"Item\"))\r\n\r\nlocal LOOT_TABLE = World.FindObjectByName(\"LootTables\"):GetChildren()\r\nlocal SALVAGE_TABLE = World.FindObjectByName(\"Salvagables\"):GetChildren()\r\nlocal REGISTERED_ITEMS = World.FindObjectByName(\"RegisteredItems\")\r\nlocal ITEM_TYPES_FOLDER = World.FindObjectByName(\"ItemTypes\")\r\n\r\n--local LOOT_TABLE = script:GetCustomProperty(\"LootTable\"):WaitForObject():GetChildren()\r\n--local SALVAGE_TABLE = script:GetCustomProperty(\"SalvageTable\"):WaitForObject():GetChildren()\r\n--local REGISTERED_ITEMS = script:GetCustomProperty(\"RegisteredItems\"):WaitForObject()\r\n\r\n\r\n\r\n-- Load the database over a fixed number of frames.\r\nlocal LOAD_FRAME_LIMIT = 10\r\n\r\n-- If true, when the game loads it will log all the catalogs and their items that are registered to that catalog.\r\nlocal DEBUGLOGLOAD = false \r\n\r\nlocal DATA_ITEMS = {}\r\nlocal DATA_ITEMTYPES_UPGRADES = {}\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- SETUP\r\n---------------------------------------------------------------------------------------------------------\r\n\r\nlocal function HasRequiredProperties(item)\r\n    if item:GetCustomProperty(\"Name\") and\r\n        item:GetCustomProperty(\"Icon\") and\r\n        item:GetCustomProperty(\"ItemType\") and\r\n        item:GetCustomProperty(\"Rarity\") then\r\n        return true\r\n    else\r\n        return false\r\n    end\r\nend\r\n\r\n-- Load the upgrade items for the item types.\r\nlocal function LoadItemTypeUpgrades(folder)\r\n    if not folder then\r\n        warn(\"No item types folder provided. Can not load upgrade items for items.\")\r\n        return\r\n    end\r\n    for _, itemType in pairs(folder:GetChildren()) do\r\n        local enhacementItem = itemType:GetCustomProperty(\"EnhancementItem\") and itemType:GetCustomProperty(\"EnhancementItem\"):WaitForObject() or nil\r\n        local limitBreakItem = itemType:GetCustomProperty(\"LimitBreakingItem\") and itemType:GetCustomProperty(\"LimitBreakingItem\"):WaitForObject() or nil\r\n\r\n        if enhacementItem and limitBreakItem then\r\n            local itemTypeName = itemType.name\r\n            DATA_ITEMTYPES_UPGRADES[itemTypeName] = { \r\n                enhancmentItemName = enhacementItem:GetCustomProperty(\"Name\"),\r\n                limitBreakingItemName = limitBreakItem:GetCustomProperty(\"Name\")\r\n            }\r\n        elseif enhacementItem or limitBreakItem then\r\n            warn(string.format(\"\\nItem type - %s requires both an enhacement item and a limit breaking item custom property that references an existing item. \\n You currently have one out of the two required properties.\",itemType.name))\r\n        end\r\n    end\r\nend\r\n\r\n-- Recursively load the item database.\r\nlocal function LoadItems_R(root)\r\n    if not root then\r\n        warn(\"unable to load items for database as there is no folder provided to recursively load.\")\r\n        return \r\n    end\r\n    for _, item in pairs(root:GetChildren()) do\r\n        if HasRequiredProperties(item) then\r\n            table.insert(DATA_ITEMS,item)\r\n        elseif #item:GetChildren() > 0 then\r\n            LoadItems_R(item)\r\n        end\r\n    end\r\nend\r\nLoadItems_R(REGISTERED_ITEMS)\r\nLoadItemTypeUpgrades(ITEM_TYPES_FOLDER)\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PUBLIC\r\n---------------------------------------------------------------------------------------------------------\r\nlocal Database = {}\r\n\r\nfunction Database:WaitUntilLoaded()\r\n    while not self.isLoaded do\r\n        Task.Wait()\r\n    end\r\nend\r\n\r\n-------------- Item Factory Methods --------------\r\n-- These methods are for creating items without stats.\r\n-- This is useful for adding items to the inventory or checking for items.\r\n\r\nfunction Database:GetItemFromName(itemName)\r\n    local itemData = Database:FindItemDataByName(itemName)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right name?\",itemName))\r\n    end\r\n    return item\r\nend\r\n\r\nfunction Database:GetItemFromMUID(muid)\r\n    local itemData = Database:FindItemDataByFullMUID(muid) or Database:FindItemDataByMUID(muid)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right muid?\",muid))\r\n    end\r\n    local item = Item.New(itemData)\r\n    return item\r\nend\r\n\r\nfunction Database:GetItemFromIndex(index)\r\n    local itemData = Database:FindItemDataByIndex(index)\r\n    local item = Item.new(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right index?\",index))\r\n    end\r\n    return item\r\nend\r\n\r\nfunction Database:CreateItemFromHash(itemHash)\r\n    local item = Item.FromHash(self, itemHash)\r\n    if not item then\r\n        warn(string.format(\"Failed to create item - %s from database. This may not be a valid hash.\",itemHash))\r\n    end\r\n    return item\r\nend\r\n\r\n-------------- Loot Factory Methods ---------------\r\n-- These methods are for creating items that roll for stats\r\n-- This is useful for creating items that need stats.\r\n\r\nfunction Database:CreateLootItemFromName(itemName)\r\n    local itemData, min, max = Database:FindItemDataByName(itemName)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right name?\",itemName))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\nfunction Database:CreateLootItemFromMUID(muid)\r\n    local itemData, min, max = Database:FindItemDataByFullMUID(muid) or Database:FindItemDataByMUID(muid)\r\n    local item = Item.New(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right muid?\",muid))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\nfunction Database:CreateLootItemFromIndex(index)\r\n    local itemData, min, max = Database:FindItemDataByIndex(index)\r\n    local item = Item.new(itemData)\r\n    if not itemData then\r\n        warn(string.format(\"Failed to create item - %s from database. Are you sure this is the right index?\",index))\r\n    end\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item\r\nend\r\n\r\n-- Create a random item from a loot table when provided a name of an existing loot table.\r\nfunction Database:CreateLootItemFromDropKey(dropKey)\r\n    local itemData, min, max = self:_RollDrop(dropKey)\r\n    if not itemData then\r\n        warn(string.format([[ \r\n        Failed to create item from - %s loot table. Does this loot table exist in item registry?\r\n        ]],dropKey))\r\n        return nil\r\n    end\r\n    if itemData == nil or itemData == \"Empty\" then return end\r\n    --assert(itemData, string.format(\"Could not drop an item from %s loot table as it does not exist.\", dropKey))\r\n    local item = Item.New(itemData)\r\n    if min and max then\r\n        item:SetStackSize(math.random(min,max))\r\n    end\r\n    self:_RollItemStats(item)\r\n    return item \r\nend\r\n\r\nfunction Database:CreateLootItemFromItemData(itemData)\r\n    itemData._RollStats = self:_GetRollFunction(itemData.statKey)\r\n    local item = Item.New(itemData)\r\n    self:_RollItemStats(item)\r\n    return item \r\nend\r\n-----------------------------------------------\r\n\r\n-- Returns a table containing the data of an item when provided with the name of the item. Example: 1\r\nfunction Database:FindItemDataByIndex(itemIndex)\r\n    return self.itemDatasByIndex[itemIndex]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with the name of the item. Example: Wood\r\nfunction Database:FindItemDataByName(itemName)\r\n    return self.itemDatasByName[itemName]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with a full MUID. Example: F2F89CB6DC0893B7:ITEM_Misc_Wood\r\nfunction Database:FindItemDataByFullMUID(itemMUID)\r\n    return self.itemDatasByMUIDFull[itemMUID]\r\nend\r\n\r\n-- Returns a table containing the data of an item when provided with a MUID. Example: F2F89CB6DC0893B7\r\nfunction Database:FindItemDataByMUID(itemMUID)\r\n    return self.itemDatasByMUID[itemMUID]\r\nend\r\n\r\nfunction Database:RandomDropKey()\r\n    return self.itemDropKeys[math.random(#self.itemDropKeys)]\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PRIVATE\r\n---------------------------------------------------------------------------------------------------------\r\nfunction Database:_Init()\r\n    self.itemStatRollInfos = {}\r\n    Task.Spawn(function()\r\n        self:_LoadItems()\r\n        self:_LoadDrops()\r\n        self.isLoaded = true\r\n    end)\r\nend\r\n\r\n-- Finds the stats folder of an item and loads it.\r\nfunction Database:_LoadStats(item,itemPropName)\r\n    local stats = item:FindChildByName(\"Stats\")\r\n    if stats == nil then return end\r\n    self.itemStatRollInfos[itemPropName] = self.itemStatRollInfos[itemPropName] or { base = {}, bonus = {} }\r\n    local statRollInfos = self.itemStatRollInfos[itemPropName]\r\n    for _,statFolder in ipairs(stats:GetChildren()) do\r\n        if statFolder.name == \"Base\" then\r\n            for _, stat in ipairs(statFolder:GetChildren()) do\r\n                local min = stat:GetCustomProperty(\"Min\")\r\n                local max = stat:GetCustomProperty(\"Max\")\r\n                local likelihood = stat:GetCustomProperty(\"Likelihood\")\r\n                local rollInfo = { statName = stat.name, rollMin = tonumber(min), rollMax = tonumber(max), likelihood = tonumber(likelihood) }\r\n                table.insert(statRollInfos.base, rollInfo)\r\n            end\r\n        else\r\n            for _, stat in ipairs(statFolder:GetChildren()) do\r\n                local min = stat:GetCustomProperty(\"Min\")\r\n                local max = stat:GetCustomProperty(\"Max\")\r\n                local likelihood = stat:GetCustomProperty(\"Likelihood\")\r\n                statRollInfos.bonus[statFolder.name] = statRollInfos.bonus[statFolder.name] or { cumulativeLikelihood = 0 }\r\n                local bonusGroup = statRollInfos.bonus[statFolder.name]\r\n                bonusGroup.cumulativeLikelihood = bonusGroup.cumulativeLikelihood + likelihood\r\n                local rollInfo = { statName = stat.name, rollMin = tonumber(min), rollMax = tonumber(max), likelihood = tonumber(likelihood) }\r\n                table.insert(bonusGroup, rollInfo)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-- Finds the assiociated salvage components folder for the item and loads the componenents into a table\r\nfunction Database:_LoadSalvageComponents(itemTemplate)\r\n    for _, salvagableItem in pairs(SALVAGE_TABLE) do\r\n        if salvagableItem:GetCustomProperty(\"ItemToSalvage\") == itemTemplate then\r\n            local resources = {}\r\n            for i, component in pairs(salvagableItem:GetChildren()) do\r\n                local componentProperties = component:GetCustomProperties()\r\n                assert(componentProperties[\"ItemProduct\"],string.format(\"%s in salvagables folder contains a component that does not have an assigned item.\",salvagableItem.name))\r\n                local item = componentProperties[\"ItemProduct\"] -- The item asset reference\r\n                local amount = componentProperties[\"Amount\"] or 1 -- The amount of that item\r\n                table.insert(resources,{ item = item, amount = amount })\r\n            end\r\n            return resources ~= {} and resources or nil\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:_LoadItems()\r\n    self.itemDatasByIndex = {}\r\n    self.itemDatasByName = {}\r\n    self.itemDatasByMUIDFull = {}\r\n    self.itemDatasByMUID = {}\r\n    local index = 1\r\n    if DEBUGLOGLOAD then print(\"Loading Items ----------------------------------------------------- \\n\") end -- Debug\r\n    for index, item in ipairs(DATA_ITEMS) do\r\n        if index % LOAD_FRAME_LIMIT == 0 then Task.Wait() end\r\n        local itemMUID = item:GetCustomProperty(\"Item\")\r\n        local propName = item:GetCustomProperty(\"Name\")\r\n        local propIcon = item:GetCustomProperty(\"Icon\")\r\n        local propMaxStackableSize = item:GetCustomProperty(\"MaxStackableSize\")\r\n        local propItemType = item:GetCustomProperty(\"ItemType\")\r\n        local propDescription = item:GetCustomProperty(\"Description\")\r\n        local propRarity = item:GetCustomProperty(\"Rarity\")\r\n        local propLevelRequirement = item:GetCustomProperty(\"LevelRequirement\")\r\n        local propEquipmentStance = item:GetCustomProperty(\"EquipmentStance\")\r\n        local propConsumptionEffect = item:GetCustomProperty(\"ConsumptionEffect\")\r\n        local propBackpackSlotCount = item:GetCustomProperty(\"BackpackSlotCount\")\r\n        local isBackpack = propBackpackSlotCount and true or false\r\n        local salvageComponents = self:_LoadSalvageComponents(itemMUID) -- Load salvage components for the item\r\n        self:_LoadStats(item,propName) -- Load stats from the item\r\n\r\n        if DEBUGLOGLOAD then print(propName) end -- Debug\r\n        if DEBUGLOGLOAD then print(\"|\",itemMUID, \"    =\",propName) end -- Debug\r\n\r\n        if propMaxStackableSize and not Item.ALLOW_LARGE_STACK_SIZES then\r\n            assert(tonumber(propMaxStackableSize) <= 2^12, string.format(\"item stack size is too large - %s \\n if you want larger stack sizes that exceed 2^12 then enable AllowLargeStacksizes custom property on ItemSystems_Item in project content. Enabling this will allow up to 2^24 increasing the maximum amount for stack sizes.\", propName))\r\n        elseif propMaxStackableSize and Item.ALLOW_LARGE_STACK_SIZES then\r\n            assert(tonumber(propMaxStackableSize) <= 2^24, string.format(\"item stack size is too large - %s \\n You can not exceed 2^24. Consider decreasing the max stack size for this item.\", propName))\r\n        end\r\n\r\n        if propConsumptionEffect then\r\n            assert(require(propConsumptionEffect), \"Could not require consumption effect script from item - %s\", propName)\r\n        end\r\n\r\n        assert(not self.itemDatasByName[propName], string.format(\"duplicate item name is not allowed - %s check your registered items for duplicates\", propName))\r\n        assert(not self.itemDatasByMUIDFull[itemMUID], string.format(\"duplicate item MUID is not allowed - %s on item: %s\", itemMUID, propName))\r\n        assert(Item.SLOT_CONSTRAINTS[propItemType], string.format(\"unrecognized item type - %s from %s add your item type to the ItemTypes folder in ItemRegistry\", propItemType, propName))\r\n        assert(Item.RARITIES[propRarity], string.format(\"unrecognized item rarity - %s check ItemSystems_ItemThemes to make sure this rarity exist.\", propRarity))\r\n\r\n        local isEquippable = Item.SLOT_CONSTRAINTS[propItemType] and true or false\r\n        local stance = propEquipmentStance or nil\r\n        local maxStackSize = propMaxStackableSize ~= nil and propMaxStackableSize > 1 and propMaxStackableSize or nil\r\n        local enhancementItemName = DATA_ITEMTYPES_UPGRADES[propItemType] and DATA_ITEMTYPES_UPGRADES[propItemType].enhancmentItemName or nil\r\n        local limitBreakingItemName = DATA_ITEMTYPES_UPGRADES[propItemType] and DATA_ITEMTYPES_UPGRADES[propItemType].limitBreakingItemName or nil\r\n        local itemData = {\r\n            index = index,\r\n            name = propName,\r\n            iconMUID = propIcon,\r\n            type = propItemType,\r\n            rarity = propRarity,\r\n            levelRequirement = propLevelRequirement,\r\n            stance = stance,\r\n            enhancementItemName = enhancementItemName,\r\n            limitBreakingItemName = limitBreakingItemName,\r\n            isEquippable = isEquippable,\r\n            isBackpack = isBackpack,\r\n            backpackSlotCount = propBackpackSlotCount,\r\n            maxStackSize = maxStackSize,\r\n            muid = itemMUID:match(\"^(.+):\"),\r\n            description = propDescription or \"\",\r\n            consumptionEffect = propConsumptionEffect,\r\n            salvageComponents = salvageComponents,\r\n            _RollStats = Database:_GetRollFunction(propName)\r\n        }\r\n\r\n        index = index + 1\r\n        self.itemDatasByIndex[itemData.index] = itemData\r\n        self.itemDatasByName[itemData.name] = itemData\r\n        self.itemDatasByMUIDFull[itemMUID] = itemData\r\n        self.itemDatasByMUID[itemMUID:match(\"^(.+):\")] = itemData\r\n        if DEBUGLOGLOAD then print(\"\\n\") end -- Debug\r\n    end\r\n    if DEBUGLOGLOAD then print(\"Loading Items Ended -----------------------------------------------\\n\") end -- Debug\r\nend\r\n\r\nfunction Database:_RollItemStats(item)\r\n    item:RollStats()\r\nend\r\n\r\nfunction Database:_GetRollFunction(itemName)\r\n    local _RollStats = function()\r\n        local statRollInfos = self.itemStatRollInfos[itemName]\r\n        if statRollInfos == nil then return end -- If the item does not have stats.\r\n        local stats = {}\r\n        for _,rollInfo in ipairs(statRollInfos.base) do\r\n            local statInfo = Item._StatInfo{\r\n                name = rollInfo.statName,\r\n                value = math.random(rollInfo.rollMin, rollInfo.rollMax),\r\n                isBase = true,\r\n            }\r\n            table.insert(stats, statInfo)\r\n        end\r\n        for _,bonusGroup in pairs(statRollInfos.bonus) do\r\n            local roll = math.random() * bonusGroup.cumulativeLikelihood\r\n            for _,rollInfo in ipairs(bonusGroup) do\r\n                if roll <= rollInfo.likelihood then\r\n                    local statInfo = Item._StatInfo{\r\n                        name = rollInfo.statName,\r\n                        value = math.random(rollInfo.rollMin, rollInfo.rollMax),\r\n                        isBonus = true\r\n                    }\r\n                    table.insert(stats, statInfo)\r\n                    break\r\n                end\r\n                roll = roll - rollInfo.likelihood\r\n            end\r\n        end\r\n        return stats\r\n    end\r\n    return _RollStats\r\nend\r\n\r\nfunction Database:_LoadDrops()\r\n    self.itemDropTables = {}\r\n    self.itemDropKeys = {}\r\n    for _, lootTable in pairs(LOOT_TABLE) do\r\n        if not self.itemDropTables[lootTable.name] then\r\n            self.itemDropTables[lootTable.name] = { cumulativeLikelihood = 0 }\r\n            table.insert(self.itemDropKeys, lootTable.name)\r\n        end\r\n        for _, lootDrop in pairs(lootTable:GetChildren()) do\r\n            local propItem = lootDrop:GetCustomProperty(\"Item\")\r\n            local item = propItem and propItem:GetObject() or \"Empty\"\r\n            local likelihood = lootDrop:GetCustomProperty(\"Likelihood\")\r\n            local minQuantity = lootDrop:GetCustomProperty(\"MinimumStackWhenDropped\")\r\n            local maxQuantity = lootDrop:GetCustomProperty(\"MaximumStackWhenDropped\")\r\n            if item == \"Empty\" and likelihood then\r\n                local dropTable = self.itemDropTables[lootTable.name]\r\n                local dropInfo = { itemName = \"Empty\", likelihood = tonumber(likelihood)}\r\n                table.insert(dropTable, dropInfo)\r\n                dropTable.cumulativeLikelihood = dropTable.cumulativeLikelihood + dropInfo.likelihood\r\n            elseif item ~= \"Empty\" then\r\n                local itemName = item:GetCustomProperty(\"Name\")\r\n                if not self:FindItemDataByName(itemName) then\r\n                    warn(string.format(\"%s group inside the loot table - %s. The group\'s item property does not reference a registered item.\",lootDrop.name,lootTable.name))\r\n                end\r\n                if not likelihood then\r\n                    warn(string.format(\"Likelihood property is missing from %s in loot table %s\",lootDrop.name,lootTable.name))\r\n                end\r\n                if itemName and likelihood then\r\n                    local dropTable = self.itemDropTables[lootTable.name]\r\n                    local dropInfo = { itemName = itemName, likelihood = tonumber(likelihood), min = minQuantity, max = maxQuantity }\r\n                    table.insert(dropTable, dropInfo)\r\n                    dropTable.cumulativeLikelihood = dropTable.cumulativeLikelihood + dropInfo.likelihood\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:_RollDrop(dropKey)\r\n    local dropTable = self.itemDropTables[dropKey]\r\n    if dropTable then\r\n        local roll = math.random() * dropTable.cumulativeLikelihood\r\n        for _,dropInfo in ipairs(dropTable) do\r\n            if roll <= dropInfo.likelihood then\r\n                local item, min, max = self:FindItemDataByName(dropInfo.itemName), dropInfo.min, dropInfo.max \r\n                if dropInfo.itemName == \"Empty\" then\r\n                    return \"Empty\", min, max\r\n                end\r\n                return item, min, max\r\n            end\r\n            roll = roll - dropInfo.likelihood\r\n        end\r\n    end\r\nend\r\n\r\nfunction Database:__tostring()\r\n    return \"\"\r\nend\r\n\r\nreturn Database"
        CustomParameters {
          Overrides {
            Name: "cs:Item"
            AssetReference {
              Id: 5903881589588767374
            }
          }
        }
      }
    }
    Assets {
      Id: 5903881589588767374
      Name: "ItemSystems_Item"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Item\r\n    ================\r\n\r\n    Logical representation of an item.\r\n]]\r\nlocal Base64 = require(script:GetCustomProperty(\"Base64\"))\r\nlocal ITEM_TYPES_FOLDER = World.FindObjectByName(\"ItemTypes\")\r\n\r\nlocal Item = {}\r\nItem.__index = Item\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- CONSTANTS\r\n---------------------------------------------------------------------------------------------------------\r\nlocal function Enum(values) for i,v in ipairs(values) do values[v] = i end return values end\r\n\r\nItem.STATS = Enum{\r\n    \"Health\",\r\n    \"HealthPercent\",\r\n    \"Attack\",\r\n    \"Defense\",\r\n    \"Magic\",\r\n    \"CritChance\",\r\n    \"CDR\",\r\n    \"Haste\",\r\n    \"Tenacity\",\r\n    \"Value\",\r\n}\r\n\r\nItem.RARITIES = Enum{\r\n    \"Common\",\r\n    \"Uncommon\",\r\n    \"Rare\",\r\n    \"Epic\",\r\n    \"Legendary\",\r\n}\r\n\r\nItem.SLOT_CONSTRAINTS = {}\r\n\r\nfor _, item in pairs(ITEM_TYPES_FOLDER:GetChildren()) do\r\n    local typeName = item.name\r\n    Item.SLOT_CONSTRAINTS[typeName] = { slotType = item:GetCustomProperty(\"EquipSlotType\"),\r\n                                        isOffHandDisabled = item:GetCustomProperty(\"IsOffHandDisabled\"), }\r\nend\r\n\r\n-- Global flag for allowing 2^24 stack sizes instead of 2^12\r\nItem.ALLOW_LARGE_STACK_SIZES = script:GetCustomProperty(\"AllowLargeStacksizes\")\r\n\r\n-- Enhancement cap.\r\nItem.ENHANCEMENT_CAP = 10\r\nItem.ENHANCEMENT_STAT_PERCENT_INCREASE = 10\r\n\r\n-- Limit break caps by rarity.\r\nItem.LIMIT_BREAK_CAPS = {\r\n    Common    = 1,\r\n    Uncommon  = 2,\r\n    Rare      = 3,\r\n    Epic      = 4,\r\n    Legendary = 5,\r\n}\r\n\r\n-- These are close to the geometric series 4^n, but are chosen to be prime numbers so that combinations look more \"random\".\r\nItem.SHARD_RARITY_MULTIPLIERS = {\r\n    Common      = 3,\r\n    Uncommon    = 7,\r\n    Rare        = 23,\r\n    Epic        = 79,\r\n    Legendary   = 248,\r\n}\r\n\r\n---------------------------------------------------------------------------------------------------------\r\n-- PUBLIC\r\n---------------------------------------------------------------------------------------------------------\r\nfunction Item.New(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    local o = {}\r\n    setmetatable(o, Item)\r\n    o:_Init(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    return o\r\nend\r\n\r\nfunction Item.FromHash(database, itemHash)\r\n    return Item._FromHash(database, itemHash)\r\nend\r\n\r\nfunction Item.StatGreaterThan(item1, item2, statName)\r\n    return item1:GetStatTotal(statName) > item2:GetStatTotal(statName) or false\r\nend\r\n\r\nfunction Item:NewBackpackInventory(Inventory, database, owner, inventoryHash)\r\n    if self:IsBackpack() then\r\n        if not owner then return end\r\n        local newInventory = Inventory.New(database,owner,self.data.backpackSlotCount,nil)\r\n        newInventory:LoadHash(inventoryHash)\r\n        self:SetBackpackInventory(newInventory)\r\n    end\r\nend\r\n\r\nfunction Item:GetBackpackInventory()\r\n    if self:IsBackpack() then\r\n        return self.backpackInventory\r\n    end\r\nend\r\n\r\nfunction Item:SetBackpackInventory(inventory)\r\n    if self:IsBackpack() then\r\n        self.backpackInventory = inventory\r\n    end\r\nend\r\n\r\nfunction Item:RuntimeHash()\r\n    return self:_IntoHash(true)\r\nend\r\n\r\nfunction Item:PersistentHash()\r\n    return self:_IntoHash(false)\r\nend\r\n\r\nfunction Item:GetID()\r\n    return self.data.index\r\nend\r\n\r\nfunction Item:GetName()\r\n    return self.data.name\r\nend\r\n\r\nfunction Item:GetType()\r\n    return self.data.type\r\nend\r\n\r\nfunction Item:GetIcon()\r\n    return self.data.iconMUID\r\nend\r\n\r\nfunction Item:GetLevelRequirement()\r\n    return self.data.levelRequirement\r\nend\r\n\r\nfunction Item:GetRarity()\r\n    return self.data.rarity\r\nend\r\n\r\nfunction Item:IsEquippable()\r\n    return self.data.isEquippable\r\nend\r\n\r\nfunction Item:IsTwoHanded()\r\n    return self.SLOT_CONSTRAINTS[self:GetType()].isOffHandDisabled\r\nend\r\n\r\nfunction Item:IsBackpack()\r\n    return self.data.isBackpack\r\nend\r\n\r\nfunction Item:GetEquipSlotType()\r\n    if self:IsEquippable() then\r\n        return self.SLOT_CONSTRAINTS[self:GetType()].slotType\r\n    end\r\nend\r\n\r\nfunction Item:IsStackable()\r\n    return self.data.maxStackSize ~= nil\r\nend\r\n\r\nfunction Item:GetStackSize()\r\n    return self.stackSize\r\nend\r\n\r\nfunction Item:SetStackSize(stackSize)\r\n    assert(self:IsStackable() and stackSize >= 0)\r\n    self.stackSize = stackSize\r\nend\r\n\r\nfunction Item:GetMaxStackSize()\r\n    return self.data.maxStackSize\r\nend\r\n\r\nfunction Item:IsFullStack()\r\n    return self:GetStackSize() == self:GetMaxStackSize()\r\nend\r\n\r\nfunction Item:WillStackWith(otherItem)\r\n    return otherItem and \r\n    self:GetMUID() == otherItem:GetMUID() and \r\n    self:IsStackable()\r\nend\r\n\r\nfunction Item:GetAvailableStackSpace()\r\n    return self:GetMaxStackSize() - self:GetStackSize()\r\nend\r\n\r\nfunction Item:ApplyIconImageSettings(uiImage)\r\n    uiImage:SetImage(self.data.iconMUID)\r\n    uiImage:SetColor(self.data.iconColorTint or Color.WHITE)\r\n    uiImage.rotationAngle = self.data.iconRotation or 0\r\n    return self.data.iconMUID\r\nend\r\n\r\nfunction Item:GetMUID()\r\n    return self.data.muid\r\nend\r\n\r\nfunction Item:GetAnimationStance()\r\n    return self.data.stance\r\nend\r\n\r\nfunction Item:GetAbilityNames()\r\n    return self.data.abilityNames\r\nend\r\n\r\nfunction Item:GetDescription()\r\n    return self.data.description\r\nend\r\n\r\nfunction Item:GetStats()\r\n    print(CoreDebug.GetStackTrace())\r\n    warn(\"Item:GetStats() is deprecated for naming reasons. Use Item:GetStatsBase() instead.\")\r\n    return self.stats\r\nend\r\n\r\nfunction Item:HasStats()\r\n    return self.hasStats\r\nend\r\n\r\n-- Returns a table of the item\'s base stats.\r\nfunction Item:GetStatsBase()\r\n    return self.stats\r\nend\r\n\r\n-- Returns a table of the item\'s enhanced stats.\r\nfunction Item:GetStatsEnhanced()\r\n    return self.statsEnhanced\r\nend\r\n\r\nfunction Item:GetStatTotal(statName)\r\n    return self.statTotals[statName] or 0\r\nend\r\n\r\nfunction Item:GetSalvageComponents()\r\n    -- Returns a table containg salavage data of the item\r\n    -- {\r\n    --      componentItem = assetRef,\r\n    --      amount = int, \r\n    -- }\r\n    return self.data.salvageComponents\r\nend\r\n\r\nfunction Item:Clone()\r\n    local clone = Item.New(self.data, self:GetStackSize(), self:GetEnhancementLevel(), self:GetLimitBreakLevel())\r\n    clone:CopyStats(self)\r\n    return clone\r\nend\r\n\r\nfunction Item:CopyStats(other)\r\n    self.stats = {}\r\n    for i,stat in ipairs(other.stats) do\r\n        self.stats[i] = { name = other.stats[i].name, value = other.stats[i].value }\r\n    end\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:ClearStats()\r\n    self.stats = {}\r\nend\r\n\r\nfunction Item:RollStats()\r\n    self.stats = self.data:_RollStats()\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:HasConsumptionEffect()\r\n    return self:GetType() == \"Consumable\" and self.data.consumptionEffect ~= nil\r\nend\r\n\r\nfunction Item:ApplyConsumptionEffect(player)\r\n    if self.data.consumptionEffect then\r\n        require(self.data.consumptionEffect)(player)\r\n    end\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Enhancement API Methods\r\nfunction Item:GetEnhancementLevel()\r\n    return self.enhancementLevel\r\nend\r\n\r\nfunction Item:GetMaxEnhancementLevel()\r\n    return self.ENHANCEMENT_CAP * self:GetLimitBreakLevel()\r\nend\r\n\r\nfunction Item:SetEnhancementLevel(enhancementLevel)\r\n    assert(1 <= enhancementLevel and enhancementLevel <= self:GetMaxEnhancementLevel())\r\n    self.enhancementLevel = enhancementLevel\r\n    self:_RecalculateStatTotals()\r\nend\r\n\r\nfunction Item:IsFullyEnhanced()\r\n    return self.enhancementLevel == self:GetMaxEnhancementLevel()\r\nend\r\n\r\nfunction Item:GetRequiredEnhancementItemName()\r\n    return self.data.enhancementItemName\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Limit-Break API Methods\r\n\r\nfunction Item:GetRequiredLimitBreakingItemName()\r\n    return self.data.limitBreakingItemName\r\nend\r\n\r\nfunction Item:GetLimitBreakLevel()\r\n    return self.limitBreakLevel\r\nend\r\n\r\nfunction Item:GetMaxLimitBreakLevel()\r\n    return self.LIMIT_BREAK_CAPS[self:GetRarity()]\r\nend\r\n\r\nfunction Item:SetLimitBreakLevel(limitBreakLevel)\r\n    assert(1 <= limitBreakLevel and limitBreakLevel <= self:GetMaxLimitBreakLevel())\r\n    self.limitBreakLevel = limitBreakLevel\r\nend\r\n\r\nfunction Item:IsFullyLimitBroken()\r\n    return self.limitBreakLevel == self:GetMaxLimitBreakLevel()\r\nend\r\n\r\n---------------------------------------------------------------------------------------------------------------\r\n-- Upgrade is a combination of enhancement and limit-break.\r\nfunction Item:IsNextUpgradeEnhancement()\r\n    return not self:IsFullyEnhanced()\r\nend\r\n\r\nfunction Item:IsNextUpgradeLimitBreak()\r\n    return self:IsFullyEnhanced() and not self:IsFullyLimitBroken()\r\nend\r\n\r\nfunction Item:CanUpgrade()\r\n    return self:HasStats() and \r\n    not (self:IsFullyEnhanced() and self:IsFullyLimitBroken())\r\n    and self:GetRequiredLimitBreakingItemName()\r\n    and self:GetRequiredEnhancementItemName()\r\nend\r\n\r\nfunction Item:Upgrade()\r\n    if self:IsNextUpgradeEnhancement() then\r\n        self:SetEnhancementLevel(self:GetEnhancementLevel() + 1)\r\n    elseif self:IsNextUpgradeLimitBreak() then\r\n        self:SetLimitBreakLevel(self:GetLimitBreakLevel() + 1)\r\n        self:SetEnhancementLevel(self:GetEnhancementLevel() + 1)\r\n    end\r\n    self:_RecalculateStatTotals()\r\nend\r\n---------------------------------------------------------------------------------------------------------\r\n-- PRIVATE\r\n---------------------------------------------------------------------------------------------------------\r\nlocal HASH_RUNTIME = \"R\"\r\nlocal HASH_PERSISTENT = \"P\"\r\nlocal HASH_DELIM_INTRO = \"|\"\r\nlocal HASH_DELIM_SUBINV = \">\"\r\nlocal HASH_DELIM_STAT_BASE = \"#\"\r\nlocal HASH_DELIM_STAT_BONUS = \"&\"\r\nlocal HASH_DELIM_STAT_EQUALS = \"=\"\r\nlocal HASH_PATTERN_FULL = \"^(.*)|(.*)|(.*)|(.*)|(.*)|(.*)$\"\r\nlocal HASH_PATTERN_STAT = \"([#&])([^#&=]+)=(....)\"\r\nlocal HASH_INVENTORY_PATTERN = \"<([^<>;]+)>([^<>;]+)<([^<>;]+)>;\"\r\n\r\nfunction Item._StatInfo(statInfo)\r\n    assert(statInfo.name, \"stat info missing name\")\r\n    assert(statInfo.value, \"stat info missing value\")\r\n    assert(statInfo.isBase or statInfo.isBonus, \"stat must be either base or bonus\")\r\n    return statInfo\r\nend\r\n\r\nfunction Item:_Init(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    self.data = itemData\r\n    self.stackSize = stackSize or 1\r\n    self.enhancementLevel = enhancementLevel or 1\r\n    self.limitBreakLevel = limitBreakLevel or 1\r\n    self.stats = {}\r\n    self.statTotals = {}\r\n    self.backpackInventory = nil\r\nend\r\n\r\nfunction Item:_IntoHash(isRuntime)\r\n    local hashParts = {}\r\n    table.insert(hashParts, isRuntime and HASH_RUNTIME or HASH_PERSISTENT)\r\n    table.insert(hashParts, isRuntime and Base64.Encode24(self.data.index) or self.data.muid)\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    if Item.ALLOW_LARGE_STACK_SIZES then\r\n        table.insert(hashParts, Base64.Encode24(self:GetStackSize()))\r\n    else\r\n        table.insert(hashParts, Base64.Encode12(self:GetStackSize()))\r\n    end\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    table.insert(hashParts, Base64.Encode6(self:GetEnhancementLevel()))\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    table.insert(hashParts, Base64.Encode6(self:GetLimitBreakLevel()))\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    if self.stats ~= nil then\r\n        for _,stat in ipairs(self.stats) do\r\n            local statIndex = self.STATS[stat.name]\r\n            local statDelimiter = stat.isBase and HASH_DELIM_STAT_BASE or HASH_DELIM_STAT_BONUS\r\n            local statKey = isRuntime and Base64.Encode6(statIndex) or stat.name\r\n            local statValue = Base64.Encode24(stat.value)\r\n            table.insert(hashParts, statDelimiter)\r\n            table.insert(hashParts, statKey)\r\n            table.insert(hashParts, HASH_DELIM_STAT_EQUALS)\r\n            table.insert(hashParts, statValue)\r\n        end\r\n    end\r\n\r\n    table.insert(hashParts, HASH_DELIM_INTRO)\r\n    local subItemCount = 0\r\n    if self:IsBackpack() then\r\n        local backpackInventory = self:GetBackpackInventory()\r\n        if backpackInventory and self:IsBackpack() then\r\n            for i, item in backpackInventory:IterateEntireInventory() do\r\n                if item then\r\n                    subItemCount = subItemCount + 1\r\n                end\r\n            end\r\n        end\r\n        local inventoryHash = isRuntime and HASH_RUNTIME or HASH_PERSISTENT\r\n        if backpackInventory and isRuntime then\r\n            inventoryHash = backpackInventory:RuntimeHash()\r\n        elseif backpackInventory then\r\n            inventoryHash = backpackInventory:PersistentHash()\r\n        end\r\n        table.insert(hashParts, string.format(\"<%i>\", subItemCount))\r\n        table.insert(hashParts, \";\")\r\n        table.insert(hashParts, inventoryHash:sub(2))\r\n    else\r\n        table.insert(hashParts, string.format(\"<%i>\", subItemCount))\r\n    end\r\n    return table.concat(hashParts)\r\nend\r\n\r\nfunction Item._FromHash(database, hash)\r\n    local hashType = hash:sub(1, 1)\r\n    local hashData = hash:sub(2)\r\n    local isRuntime = hashType == HASH_RUNTIME\r\n    local hashItemId, hashStackSize, hashEnhancementLevel, hashLimitBreakLevel, hashItemStats, backpackSubHash = hashData:match(HASH_PATTERN_FULL)\r\n    local itemData = nil\r\n    if isRuntime then\r\n        itemData = database:FindItemDataByIndex(Base64.Decode24(hashItemId))\r\n    else\r\n        itemData = database:FindItemDataByMUID(hashItemId)\r\n    end\r\n    if not itemData then\r\n        warn(\"unable to locate item data for hash: \", hashData)\r\n        return\r\n    end\r\n\r\n\r\n    local stackSize = 0\r\n    if Item.ALLOW_LARGE_STACK_SIZES then\r\n        -- Decode12 -> Decode24\r\n        if string.len(hashStackSize) == 2 then\r\n            stackSize = hashStackSize and Base64.Decode12(hashStackSize) or nil\r\n            hashStackSize = Base64.Encode24(stackSize) -- Convert 12 to 24\r\n        end\r\n        -- 2^24 = 16777216 max stack size.\r\n        stackSize = hashStackSize and Base64.Decode24(hashStackSize) or nil\r\n    else\r\n        -- Decode24 -> Decode12 ( With limits considered )\r\n        if string.len(hashStackSize) == 4 then\r\n            stackSize = hashStackSize and Base64.Decode24(hashStackSize) or nil\r\n            if stackSize > 2^12 then\r\n                warn(string.format(\"Allow large stack size custom property on ItemSystems_Item was turned off while there was items that exceeded 2^12 in stack size. Reducing the stack size to maxmium amount allowable by the item - %s\",itemData.name))\r\n                if itemData.maxStackSize > 2^12 then\r\n                    stackSize = 2^12\r\n                else\r\n                    stackSize = itemData.maxStackSize\r\n                end\r\n            end\r\n            hashStackSize = Base64.Encode12(stackSize) -- Convert 24 to 12\r\n        end\r\n        -- 2^12 = 4096 max stack size.\r\n        stackSize = hashStackSize and Base64.Decode12(hashStackSize) or nil\r\n    end\r\n\r\n    local enhancementLevel = hashEnhancementLevel and Base64.Decode6(hashEnhancementLevel) or nil\r\n    local limitBreakLevel = hashLimitBreakLevel and Base64.Decode6(hashLimitBreakLevel) or nil\r\n    local item = Item.New(itemData, stackSize, enhancementLevel, limitBreakLevel)\r\n    for statDelimiter,statNameHash,statValueHash in hashItemStats:gmatch(HASH_PATTERN_STAT) do\r\n        local statIsBase = statDelimiter == HASH_DELIM_STAT_BASE or nil\r\n        local statName = isRuntime and Item.STATS[Base64.Decode6(statNameHash)] or statNameHash\r\n        local statValue = Base64.Decode24(statValueHash)\r\n        local statInfo = Item._StatInfo{ \r\n            name = statName,\r\n            value = statValue,\r\n            isBase = statIsBase or nil,\r\n            isBonus = not statIsBase or nil,\r\n        }\r\n        table.insert(item.stats, statInfo)\r\n    end\r\n    item:_RecalculateStatTotals()\r\n    return item\r\nend\r\n\r\nfunction Item:_RecalculateStatTotals()\r\n    if self.stats == nil then return end\r\n\r\n    -- Clear old values.\r\n    for _,statName in ipairs(Item.STATS) do \r\n        self.statTotals[statName] = 0 \r\n    end\r\n\r\n    -- Compute enhanced stats.\r\n    local enhancementMultiplier = self:_GetEnhancementMultiplier()\r\n    self.statsEnhanced = {}\r\n    for i,stat in ipairs(self.stats) do\r\n        self.statsEnhanced[i] = {\r\n            name = stat.name,\r\n            isBase = stat.isBase,\r\n            value = math.floor(0.5 + stat.value * enhancementMultiplier),\r\n        }\r\n    end\r\n\r\n    -- Sum stats to get stat totals (effective and base).\r\n    self.hasStats = nil\r\n    for i,stat in ipairs(self.statsEnhanced) do\r\n        self.hasStats = true\r\n        self.statTotals[stat.name] = self.statTotals[stat.name] + stat.value\r\n    end\r\nend\r\n\r\nfunction Item:_GetEnhancementMultiplier()\r\n    return 1 + (math.max(0, self:GetEnhancementLevel() - 1) * self.ENHANCEMENT_STAT_PERCENT_INCREASE / 100)\r\nend\r\n\r\nfunction Item:__tostring()\r\n    local s = {}\r\n    table.insert(s, \"ITEM:\\n\")\r\n    table.insert(s, string.format(\"\\tname:   %s\\n\", self.data.name))\r\n    table.insert(s, string.format(\"\\trarity: %s\\n\", self.data.rarity))\r\n    table.insert(s, string.format(\"\\tenhancement: %s\\n\", self:GetEnhancementLevel()))\r\n    table.insert(s, string.format(\"\\tlimitBreaks: %s\\n\", self:GetLimitBreakLevel()))\r\n    if self.stats then\r\n        for _,stat in ipairs(self.stats) do\r\n            local statType = stat.isBase and \"BASE\" or \"BONUS\"\r\n            table.insert(s, string.format(\"\\tstat:   %-5s %-9s %d\\n\", statType, stat.name, stat.value))\r\n        end\r\n    end\r\n    table.insert(s, string.format(\"\\thash-R: %s\\n\", self:RuntimeHash()))\r\n    table.insert(s, string.format(\"\\thash-P: %s\\n\", self:PersistentHash()))\r\n    return table.concat(s)\r\nend\r\n---------------------------------------------------------------------------------------------------------\r\nreturn Item"
        CustomParameters {
          Overrides {
            Name: "cs:Base64"
            AssetReference {
              Id: 3976507683543157652
            }
          }
          Overrides {
            Name: "cs:AllowLargeStacksizes"
            Bool: true
          }
          Overrides {
            Name: "cs:AllowLargeStacksizes:tooltip"
            String: "When enabled the inventory will support the largest stack size that is supported by Base64. The drawback to having a larger stack size is a loss of some comprehension."
          }
        }
      }
    }
    Assets {
      Id: 3976507683543157652
      Name: "Base64"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    ItemSystems.Base64\r\n    ====================\r\n    This library is used by the Item system to transform data into a shorter length of that data so it\'s easy on the network and\r\n    for storage.\r\n]]\r\n\r\nlocal Base64 = {}\r\n\r\n-- Lookup tables for fast encode/decode.\r\nlocal SYMBOLS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-+\"\r\nlocal REVERSE = {}\r\nfor i=1,#SYMBOLS do\r\n    local c = SYMBOLS:sub(i, i)\r\n    REVERSE[c] = i - 1\r\nend\r\n-- This is useful for anyone wanting to know some other characters can still be used as protocol markers.\r\nlocal UNUSED_SYMBOLS = \"?!@#$%^&*={}[]()<>,.\"\r\n\r\n-- Store these in the class for anyone else who needs them.\r\nBase64.MATCH_PATTERN = \"[%a%d%-%+]\"\r\nBase64.UNUSED_SYMBOLS = UNUSED_SYMBOLS\r\nBase64.SYMBOLS = SYMBOLS\r\nBase64.REVERSE = REVERSE\r\n\r\n-- More useful constants so you know what you can and can\'t encode.\r\nBase64.MAX_6 = 2^6 - 1\r\nBase64.MAX_12 = 2^12 - 1\r\nBase64.MAX_24 = 2^24 - 1\r\n\r\n-- Helper for encoding.\r\nfunction raw_encode_6(uint6)\r\n    return SYMBOLS:sub(uint6+1, uint6+1)\r\nend\r\n\r\n-- Encode a 6 bit value into a character.\r\nfunction Base64.Encode6(uint6)\r\n    assert(0 <= uint6 and uint6 <= Base64.MAX_6)\r\n    return raw_encode_6(uint6)\r\nend\r\n\r\n-- Encode a 12 bit value into a string of two characters.\r\nfunction Base64.Encode12(uint12)\r\n    assert(0 <= uint12 and uint12 <= Base64.MAX_12)\r\n    local en = raw_encode_6\r\n    local b1 = en(0x3F & (uint12 >> 0))\r\n    local b2 = en(0x3F & (uint12 >> 6))\r\n    return b1 .. b2\r\nend\r\n\r\n-- Encode a 24 bit value into a string of two characters.\r\nfunction Base64.Encode24(uint24)\r\n    assert(0 <= uint24 and uint24 <= Base64.MAX_24)\r\n    local en = raw_encode_6\r\n    local b1 = en(0x3F & (uint24 >> 0))\r\n    local b2 = en(0x3F & (uint24 >> 6))\r\n    local b3 = en(0x3F & (uint24 >> 12))\r\n    local b4 = en(0x3F & (uint24 >> 18))\r\n    return b1 .. b2 .. b3 .. b4\r\nend\r\n\r\n-- Decode the next 6 bit value from the base64 string.\r\nfunction Base64.Decode6(s)\r\n    return REVERSE[s:sub(1, 1)]\r\nend\r\n\r\n-- Decode the next 12 bit value from the base64 string.\r\nfunction Base64.Decode12(s)\r\n    local sub = string.sub\r\n    local b1 = REVERSE[sub(s, 1, 1)]\r\n    local b2 = REVERSE[sub(s, 2, 2)]\r\n    return b1 | (b2 << 6)\r\nend\r\n\r\n-- Decode the next 24 bit value from the base64 string.\r\nfunction Base64.Decode24(s)\r\n    local sub = string.sub\r\n    local b1 = REVERSE[sub(s, 1, 1)]\r\n    local b2 = REVERSE[sub(s, 2, 2)]\r\n    local b3 = REVERSE[sub(s, 3, 3)]\r\n    local b4 = REVERSE[sub(s, 4, 4)]\r\n    return b1 | (b2 << 6) | (b3 << 12) | (b4 << 18)\r\nend\r\n\r\n-- Sanity check.\r\nfunction Base64._SelfTest()\r\n    assert(\"a\" == Base64.Encode6(0))\r\n    assert(\"+\" == Base64.Encode6(63))\r\n    assert(0 == Base64.Decode6(\"a\"))\r\n    assert(63 == Base64.Decode6(\"+\"))\r\n\r\n    assert(\"aa\" == Base64.Encode12(0))\r\n    assert(\"+a\" == Base64.Encode12(63))\r\n    assert(\"a+\" == Base64.Encode12(4032))\r\n    assert(\"++\" == Base64.Encode12(4095))\r\n    assert(0 == Base64.Decode12(\"aa\"))\r\n    assert(63 == Base64.Decode12(\"+a\"))\r\n    assert(4032 == Base64.Decode12(\"a+\"))\r\n    assert(4095 == Base64.Decode12(\"++\"))\r\n\r\n    assert(\"+aaa\" == Base64.Encode24(63))\r\n    assert(\"a+aa\" == Base64.Encode24(4032))\r\n    assert(\"aa+a\" == Base64.Encode24(258048))\r\n    assert(\"aaa+\" == Base64.Encode24(16515072))\r\n    assert(63 == Base64.Decode24(\"+aaa\"))\r\n    assert(4032 == Base64.Decode24(\"a+aa\"))\r\n    assert(258048 == Base64.Decode24(\"aa+a\"))\r\n    assert(16515072 == Base64.Decode24(\"aaa+\"))\r\nend\r\nBase64._SelfTest()\r\n\r\nreturn Base64"
      }
    }
    Assets {
      Id: 10260961104607564468
      Name: "RuntimeContextDetection"
      PlatformAssetType: 3
      TextAsset {
        Text: "--[[\r\n    RuntimeContextDetection\r\n\r\n    Detects the context at runtime since script.isClient or script.isServer does not help us in certain\r\n    situations\r\n]]\r\n\r\n-- Crazy that there isn\'t a builtin way to do this...\r\n\r\nreturn {\r\n    IsClientSide = function()\r\n        return World.FindObjectByName(\"___RUNTIME_CONTEXT_CLIENT\") ~= nil\r\n    end,\r\n\r\n    IsServerSide = function()\r\n        return World.FindObjectByName(\"___RUNTIME_CONTEXT_SERVER\") ~= nil\r\n    end,\r\n}"
      }
    }
  }
  SerializationVersion: 84
}
